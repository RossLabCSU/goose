'''
Backend for generation of the minimal variant.
This is code from an old version of GOOSE that I intend
to rewrite, but haven't had the chance to. It works, it just
... was written when I **REALLY** didn't know what I was doing...
But yeah, it is ... functional.
'''


import random
import metapredict as meta

from goose.goose_exceptions import GooseInputError, GooseFail
from goose.backend import parameters
from goose.backend.protein import Protein
from goose.backend.sequence_generation_backend import get_optimal_residue, random_amino_acid
from goose.backend.lists import aa_dis_val_4_v3


#weighted lists from original GOOSE

#list for generating disordered sequences with no other parameters specified
disordered_list = ['R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V']

#list for generating disordered sequences with no charged residues
neutral_IDR_list = ['H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V']

#just the negative charged amino acids
D_E = ['D', 'E', 'D', 'E', 'D', 'E', 'D', 'E']

#just the positive charged amino acids
K_R = ['K', 'R', 'K', 'R', 'K', 'R', 'K', 'R']

#just the charged amino acids
charged_list = ['D', 'E', 'D', 'E', 'D', 'E', 'D', 'E', 'K', 'R', 'K', 'R', 'K', 'R', 'K', 'R']

# standard amino acids
amino_acids = ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y']


def sequence_variant_disorder(current_sequence, original_disorder_list, cutoff=parameters.DISORDER_THRESHOLD, strict=False):
    """
    Function for determining if a sequence variant is disordered. The
    purpose of this over the typical check_disorder function for generated
    sequences is that the input sequence for a disordered variant may have
    regions that are below the cutoff value (more ordered). This function
    gets around that by allowing those regions that were originally not as disordered
    in the variant sequence to remain less disordered. However, the region will
    NEVER BE LESS DISORDERED than the input sequence, but it may become more disordered.

    This function (if strict is set to False) will allow an occassional residue
    to dip below the cutoff value.

    Parameters
    -------------

    current_sequence : String
        The variant sequence that is being checked for disorder

    original_disorder_list : List
        A list of the disorder values for the sequence input into the
        sequence variant generation function
    
    cutoff_value : float
        The cutoff value for disorder. A value of at least 0.6 is
        typically used by GOOSE.

    strict : bool
        if set to true, will not count a sequence as disordered even if a single amino
        acid falls below the cutoff value.

    Returns
    ---------

    Bool
        Returns True if the sequence is disordered
        
        Returns False if the sequence has too many residues below 
        the cutoff_val.

    """
    # just... I know.
    cutoff_val = cutoff

    # first get the list of disordered residues for the current sequence
    variant_disorder_list = meta.predict_disorder(current_sequence)

    # first make a 'modified' disorder value list so that
    # residues can go below cutoff.
    adjusted_disorder_values = []

    # for the disorder values in the disorder list
    for disorder_vals in range(0, len(variant_disorder_list)):

        # get the original disorder value at the current position
        input_disorder = original_disorder_list[disorder_vals]
        
        # if the input disorder value is greater than the specified cutoff value
        if input_disorder > cutoff_val:
            # reduce the necessary input disorder value to the cutoff value
            input_disorder = cutoff_val

        # otherwise, the input disorder value is simply equal to the disorder
        # value for the original sequence residue at the current position
        else:
            input_disorder = input_disorder

        adjusted_disorder_values.append(input_disorder)

    # keep track of consecutively ordered residues and total ordered
    cur_order_streak = 0
    total_ordered_residues = 0

    # allow up to 5 % of residues to be 'ordered' provided they aren't consecutive
    allowed_order_residues = round(0.05*len(current_sequence))
    if allowed_order_residues < 1:
        allowed_order_residues = 1

    # calculate number of conseuctively allowed residues
    # going to allow up to the length of the sequence over 25 but 
    # not greater than 10
    consec_allowed = round(len(current_sequence)/25)
    if consec_allowed < 1:
        consec_allowed = 1
    if consec_allowed > 10:
        consec_allowed = 10

    for disorder_val in range(0, len(adjusted_disorder_values)):
        # get current values for the original and the variant
        variant_disorder = variant_disorder_list[disorder_val]
        original_disorder = adjusted_disorder_values[disorder_val]

        # see if strict set to true
        if strict == True:
            if variant_disorder < original_disorder:
                return False
        else:
            if variant_disorder < original_disorder:
                cur_order_streak += 1
                total_ordered_residues += 1
            else:
                cur_order_streak = 0
            # check to see if order streak is too high
            # or total num ordered residues too high
            if cur_order_streak > consec_allowed:
                return False
            if total_ordered_residues > allowed_order_residues:
                return False

    # if all residues in the sequence variant are greater than either
    # the original value or at least the cutoff value, return True
    return True




def cleanup_sequence(sequence):

    """

    function to clean up a sequence input into a
    function that takes an input sequence


    Parameters
    -------------

    sequence : String
        The sequence that is being examined for the specified residue.

    Returns
    ---------

    clean_sequence : String 
        A version of the input sequence that holds no spaces and only
        has uppercase residues. Will not include any non-standard AAs.

    """

    # make empty string to hold the cleaned up sequence
    clean_sequence = ""

    # iterate over the amino acids in the input sequence
    for A_acid in sequence:
        # if the uppercase A_acid is in a list of standard amino acids
        if A_acid.upper() in amino_acids:
            # add the uppercase residue to the clean sequence
            clean_sequence += A_acid.upper()

    # return the cleaned up sequence
    return clean_sequence



def optimal_residue_key(four_amino_acids):

    """

    Function to translate amino acids in a sequence to the proper key for
    the dis_value dict. The dis_value dict holds the predicted disorder 
    values for thousands of distinct 5 amino acid combinations. To keep
    this dict from being so massive that it slows down GOOSE, the dict
    did not use every possible amino acid in the 4 amino acids that are
    used for prediting potential disorder values in the 5th amino acid.
    For example, all aromatics were treated as equivalent. This reduced
    the total lenth of the dict by several orders of magnitude.


    Parameters
    -------------

    four_amino_acids : String
        The 4 amino acids used from the input sequence that 
        are to be used for prdicting disorder


    Returns
    ---------

    key : String
        Returns 4 amino acids that coorespond to the amino acids used
        for generating the dis_value dict.

    """

    # make an empty string to hold the 4 amino acids
    key = ""

    # for the amino acids in the input amino acids, change each one
    # to the corresponding amino acid used for the dis_val_dict
    for i in four_amino_acids:
        if i == "F" or i == "W" or i == "Y":
            key += "W"
        elif i == "C":
            key += "C"
        elif i == "L" or i == "V" or i == "I":
            key += "L"
        elif i == "M":
            key += "M"
        elif i == "A":
            key += "A"
        elif i == "H":
            key += "H"
        elif i == "K" or i == "R":
            key += "K"
        elif i == "Q" or i == "N":
            key += "Q"
        elif i == "D" or i == "E":
            key += "D"
        elif i == "G" or i == "S":
            key += "G"
        elif i == "T":
            key += "T"
        elif i == "P":
            key += "P"
        else:
            continue
    
    # return the final 4 amino acids that are the key to the 
    # dis_val_dict
    return key


def all_scores_at_position(sequence, position, try_residues=[]):

    """
    
    Function to get all disorder scores for a sequence
    at a specified position. Used for disorder optimization.

    Parameters
    -------------

    sequence : String
        The amino acid sequence as a string.

    position : Int
        The position of the amino acid to examine disorder scores for.

    try_residues : List
        A list of residues to try getting disorder scores fora


    Returns
    ---------
        
    List
        A list of lists that holds the amino acids that were 
        tested at the specified position as well as 
        the scores for all amino acids at the specified position
        for the specified sequence.

    """ 

    # amino acids to go through
    amino_acids = ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y']
    
    # determine if to try all amino acids or just specific ones
    if try_residues == []:
        residues_to_test = amino_acids
    else:
        residues_to_test = try_residues

    # make list to hold lists
    final_lists = []

    # make empty list to hold potential amino_acids
    candidate_amino_acids = []

    # make list to hold values
    value_list = []

    # set best val to lowest possible value
    best_val = 0

    # keep track of best amino acid just in case
    best_amino_acid = ""

    # get candidate amino acids
    for candidate in residues_to_test:
        # make the input sequence 
        # this depends on where the position of the AA of interest is
        if position == len(sequence)-1:
            input_sequence = sequence[0:position] + candidate
        elif position == 0:
            input_sequence = candidate + sequence[1:]
        else:
            input_sequence = sequence[0:position] + candidate + sequence[position+1:]

        # calculate disorder values
        # use sum of disorder for sequence to make sure disorder
        # is globally maximized
        disorder_val = sum(meta.predict_disorder(input_sequence))

        # append values to value_list
        value_list.append(disorder_val)

    # append lists to final list
    final_lists.append(residues_to_test)
    final_lists.append(value_list)

    # return list of candidate amino acids and their disorder values
    return final_lists


def increase_charge_asymmetry(sequence, cutoff=0.65, attempts=20, exclude = [], check_disorder=True):
    
    """
    
    Function to increase charge asymmetry of an input sequence.
    Uses some randomness during generation in case the generated 
    does not reach the cutoff value (then can retry a different
    sequence)

    Parameters
    -------------

    sequence : String
        The amino acid sequence as a string.

    cutoff : Float
        The cutoff value used for disorder

    attempts : Int
        Number of attempts to make disordered sequence

    exclude : List
        A list of residues to exclude moving when altering asymmetry

    check_disorder : Bool
        Whether to check disorder of the generated sequence


    Returns
    ---------
        
    sequence : String
        Returns an amino acid sequence with an increased charge asymmetry

    """
    
    sequence = cleanup_sequence(sequence)

    # get disorder of the sequence
    if check_disorder == True:
        starting_disorder = meta.predict_disorder(sequence)


    # identify positions of negative and positive residues in a sequence
    if 'E' not in exclude:
        E_coordinates = identify_residue_positions(sequence, 'E')
    else:
        E_coordinates = []

    if 'D' not in exclude:
        D_coordinates = identify_residue_positions(sequence, 'D')
    else:
        D_coordinates = []

    if 'K' not in exclude:
        K_coordinates = identify_residue_positions(sequence, 'K')
    else:
        K_coordinates = []

    if 'R' not in exclude:
        R_coordinates = identify_residue_positions(sequence, 'R')
    else:
        R_coordinates = []

    negative_coordinates = (E_coordinates + D_coordinates)
    positive_coordinates = (K_coordinates + R_coordinates)

    # figure out what residues can be targeted and where to put them based on charge distribution
    if len(positive_coordinates) > 0:
        positive_weight = sum(positive_coordinates)/len(positive_coordinates)
    else:
        positive_weight = 0
    
    if len(negative_coordinates) > 0:
        negative_weight = sum(negative_coordinates)/len(negative_coordinates)
    else:
        negative_weight = 0

    N=0

    while N < attempts:

        # if no charged residues just return the sequence
        if positive_weight == 0 and negative_weight == 0:
            return sequence

        # if no positive charges but have negative charges
        elif positive_weight == 0 and negative_weight > 0:
            
            # make empty string to hold final sequence
            nonmoved_res = ""
            target_negative_coordinates = []
            target_negative_residue = max(negative_coordinates)

            # identify residues to pull from final sequence
            for residue in range(0, len(sequence)):
                if residue == target_negative_residue:
                    moved_negative_residue = sequence[residue]
                else:
                    nonmoved_res += sequence[residue]

            for i in range(0, int(0.25*len(nonmoved_res))):
                if i < target_negative_residue:
                    target_negative_coordinates.append(i)  
            # if no negative_charges but have positive charges
            #elif positive_weight > 0 and negative weight == 0:

            if len(target_negative_coordinates) > 1:
                chosen_negative_position = target_negative_coordinates[random.randint(0, len(target_negative_coordinates)-1)]
            else:
                chosen_negative_position = 0        

            # build the final sequence
            final_sequence = ""

            for i in range(0, len(nonmoved_res)):
                if i == chosen_negative_position:
                    final_sequence += moved_negative_residue
                    final_sequence += nonmoved_res[i]
                else:
                    final_sequence += nonmoved_res[i]


        # if no negative charges but have positive charges
        elif positive_weight > 0 and negative_weight == 0:
            # make empty string to hold final sequence
            nonmoved_res = ""
            target_positive_coordinates = []
            target_positive_residue = max(positive_coordinates)

            # identify residues to pull from final sequence
            for residue in range(0, len(sequence)):
                if residue == target_positive_residue:
                    moved_positive_residue = sequence[residue]
                else:
                    nonmoved_res += sequence[residue]

            for i in range(0, int(0.25*len(nonmoved_res))):
                if i < target_positive_residue:
                    target_positive_coordinates.append(i)  
            # if no negative_charges but have positive charges
            #elif positive_weight > 0 and negative weight == 0:

            if len(target_positive_coordinates) > 1:
                chosen_positive_position = target_positive_coordinates[random.randint(0, len(target_positive_coordinates)-1)]
            else:
                chosen_positive_position = 0        

            # build the final sequence
            final_sequence = ""

            for i in range(0, len(nonmoved_res)):
                if i == chosen_positive_position:
                    final_sequence += moved_positive_residue
                    final_sequence += nonmoved_res[i]
                else:
                    final_sequence += nonmoved_res[i]


        else:
            # randomly decide whether to target a positive or negative residue
            chosen_val = random.randint(2, 10)
            if chosen_val % 2 == 0:
                change_positive = True
                change_negative = False
            else:
                change_positive = False
                change_negative = True

            # make empty string to hold final sequence
            nonmoved_res = ""
            target_positive_coordinates = []
            target_negative_coordinates = []
            # figure out where to put residues
            if positive_weight > negative_weight:
                # decide if targeting postiive or negative
                if change_positive == True:
                    target_positive_residue = min(positive_coordinates)
                else:
                    target_negative_residue = max(negative_coordinates)

                # identify residues to pull from final sequence
                for residue in range(0, len(sequence)):
                    if change_positive == True:
                        if residue == target_positive_residue:
                            moved_positive_residue = sequence[residue]
                        else:
                            nonmoved_res += sequence[residue]

                    else:
                        if residue == target_negative_residue:
                            moved_negative_residue = sequence[residue]
                        else:
                            nonmoved_res += sequence[residue]

                if change_positive == True:
                    for i in range(int(0.75*len(nonmoved_res)), len(nonmoved_res)):
                        if i > target_positive_residue:
                            target_positive_coordinates.append(i)
                else:
                    for i in range(0, int(0.25*len(nonmoved_res))):
                        if i < target_negative_residue:
                            target_negative_coordinates.append(i)  

            else:
                if change_positive == True:
                    target_positive_residue = max(positive_coordinates)
                else:
                    target_negative_residue = min(negative_coordinates)

                # identify residues to pull from final sequence
                for residue in range(0, len(sequence)):
                    if change_positive == True:
                        if residue == target_positive_residue:
                            moved_positive_residue = sequence[residue]
                        else: 
                            nonmoved_res += sequence[residue]
                    
                    else:
                        if residue == target_negative_residue:
                            moved_negative_residue = sequence[residue]
                        else:
                            nonmoved_res += sequence[residue]

                if change_positive == True:
                    for i in range(0, int(0.75*len(nonmoved_res))):
                        if i < target_positive_residue:
                            target_positive_coordinates.append(i)
                else:
                    for i in range(int(0.25*len(nonmoved_res)), len(nonmoved_res)):
                        if i > target_negative_residue:
                            target_negative_coordinates.append(i)            

            # choose a random target residue
            if change_positive == True:
                if len(target_positive_coordinates) > 1:
                    chosen_positive_position = target_positive_coordinates[random.randint(0, len(target_positive_coordinates)-1)]
                else:
                    if positive_weight > negative_weight:
                        chosen_positive_position = len(nonmoved_res)-1
                    else:
                        chosen_positive_position = 0
            else:
                if len(target_negative_coordinates) > 1:
                    chosen_negative_position = target_negative_coordinates[random.randint(0, len(target_negative_coordinates)-1)]
                else:
                    if negative_weight > positive_weight:
                        chosen_negative_position = len(nonmoved_res)-1
                    else:
                        chosen_negative_position = 0        


            # build the final sequence
            final_sequence = ""

            for i in range(0, len(nonmoved_res)):
                if change_positive == True:
                    if i == chosen_positive_position:
                        final_sequence += moved_positive_residue
                        final_sequence += nonmoved_res[i]
                    else:
                        final_sequence += nonmoved_res[i]

                if change_negative == True:
                    if i == chosen_negative_position:
                        final_sequence += moved_negative_residue
                        final_sequence += nonmoved_res[i]
                    else:
                        final_sequence += nonmoved_res[i]

        # check the disorder, if disordered return sequence
        if check_disorder == False:
            return final_sequence
        else:
            if sequence_variant_disorder(final_sequence, starting_disorder, cutoff) == True:
                return final_sequence

        # if it's not disordered, try again.
        N = N+1

    # if unable to create the desired sequence let user know.
    return ("Unable to increase charge asymetry without reducing disorder below threshold.")


def decrease_charge_asymmetry(sequence, cutoff=0.65, attempts=100, check_disorder=True, bloblen=5):

    """
    
    Function to decrease charge asymmetry of an input sequence.
    Uses some randomness during generation in case the generated 
    does not reach the cutoff value (then can retry a different
    sequence)

    Parameters
    -------------

    sequence : String
        The amino acid sequence as a string.

    cutoff : Float
        The cutoff value used for disorder

    attempts : Int
        Number of attempts to make disordered sequence

    check_disorder : Bool
        Whether to check disorder of the generated sequence


    Returns
    ---------
        
    sequence : String
        Returns an amino acid sequence with an increased charge asymmetry

    """
    
    # cleanup the sequence in case input has weird stuff
    sequence = cleanup_sequence(sequence)

    # get disorder of the sequence
    if check_disorder == True:
        starting_disorder = meta.predict_disorder(sequence)

    # set arbitrary lowest and highest ncpr areas
    lowest_NCPR = 100
    highest_NCPR = -100

    N = 0

    while N < attempts:

        # make lists to hold possible coords to select from randomly
        possible_lowest_NCPR_coords = []
        possible_highest_NCPR_coords = []

        for i in range(0, len(sequence)-bloblen):
            cur_blob = sequence[i: i+bloblen]
            cur_NCPR = Protein(cur_blob).NCPR
            if cur_NCPR >= highest_NCPR:
                if cur_NCPR > highest_NCPR:
                    possible_highest_NCPR_coords = [[i, i+bloblen]]
                else:
                    possible_highest_NCPR_coords.append([i, i+bloblen])
                highest_NCPR = cur_NCPR
            if cur_NCPR <= lowest_NCPR:
                if cur_NCPR < lowest_NCPR:
                    possible_lowest_NCPR_coords = [[i, i+bloblen]]
                else:
                    possible_lowest_NCPR_coords.append([i, i+bloblen])
                lowest_NCPR = cur_NCPR


        # select random lowest and highest NCPR intervals
        if len(possible_lowest_NCPR_coords) > 1:
            lowest_NCPR_blob = possible_lowest_NCPR_coords[random.randint(0, len(possible_lowest_NCPR_coords)-1)]
        else:
            lowest_NCPR_blob = possible_lowest_NCPR_coords[0]

        if len(possible_highest_NCPR_coords) > 1:
            highest_NCPR_blob = possible_highest_NCPR_coords[random.randint(0, len(possible_highest_NCPR_coords)-1)]
        else:
            highest_NCPR_blob = possible_highest_NCPR_coords[0]


        # figure out possible targets
        possible_positive_targets = []
        possible_negative_targets = []

        for aa in range(highest_NCPR_blob[0], highest_NCPR_blob[1]):
            if sequence[aa] == 'K' or sequence[aa] == 'R':
                possible_positive_targets.append(aa)

        for aa in range(lowest_NCPR_blob[0], lowest_NCPR_blob[1]):
            if sequence[aa] == 'D' or sequence[aa] == 'E':
                possible_negative_targets.append(aa)    


        # select random residue to change
        if len(possible_negative_targets) > 1:
            selected_negative_residue = possible_negative_targets[random.randint(0, len(possible_negative_targets)-1)]
        else:
            if possible_negative_targets != []:
                selected_negative_residue = possible_negative_targets[0]
            else:
                selected_negative_residue = ""

        if len(possible_positive_targets) > 1:
            selected_positive_residue = possible_positive_targets[random.randint(0, len(possible_positive_targets)-1)]
        else:
            if possible_positive_targets != []:
                selected_positive_residue = possible_positive_targets[0]
            else:
                selected_positive_residue = ""

        # make sure that there is a residue chosen to swap no matter what!

        if selected_negative_residue == "":
            selected_negative_residue = random.randint(lowest_NCPR_blob[0], lowest_NCPR_blob[1])

        if selected_positive_residue == "":
            selected_positive_residue = random.randint(highest_NCPR_blob[0], highest_NCPR_blob[1])

        #build the final sequence
        final_sequence = ""

        for i in range(0, len(sequence)):
            if i == selected_negative_residue:
                final_sequence += sequence[selected_positive_residue]
            elif i == selected_positive_residue:
                final_sequence += sequence[selected_negative_residue]
            else:
                final_sequence += sequence[i]

        if check_disorder == False:
            return final_sequence
        else:
            if sequence_variant_disorder(final_sequence, starting_disorder, cutoff) == True:        
                return final_sequence

        # keep track of number of attempts
        N = N + 1

    # if unable to generate the sequence let the user know
    return ("Unable to decrease Kappa without reducing disorder below threshold.")



def slow_optimize_hydro(input_sequence, objective_hydro, use_charged=True, additional_exclusion = []):
    """
    
    Function to take in a sequence that does not have the
    correct hydropathy and modify it to get the hydropathy 
    to become the correct value while maximizing predicted disorder

    Parameters
    -------------

    input_sequence : String
        The input sequence to optimize disorder for

    objective_hydro : Float
        The objective hydropathy value

    use_charged : Bool
        Whether or not to use charged residues as candidates

    additional_exclusion : List
        List of additional residues to exclude


    Returns
    ---------
        
    best_sequence : String
        A sequence with disorder / hydroathy further optimized

    """

    # list of charged residues
    charged_residues = ["D", "E", "K", "R"]

    # list of neutral amino acids
    neutral_AAs = ['A', 'C', 'F', 'G', 'H', 'I', 'L', 'M', 'N', 'P', 'Q', 'S', 'T', 'V', 'W', 'Y']
    
    # dict of hydropathy values
    AA_hydro = {"A": 6.3,
    "R": 0.0,
    "N": 1.0,
    "D": 1.0,
    "C": 7.0,
    "Q": 1.0,
    "E": 1.0,
    "G": 4.1,
    "H": 1.3,
    "I": 9.0,
    "L": 8.3,
    "K": 0.6,
    "M": 6.4,
    "F": 7.3,
    "P": 2.9,
    "S": 3.7,
    "T": 3.8,
    "W": 3.6,
    "Y": 3.2,
    "V": 8.7
    }

    # calculate current hydropathy
    total_hydropathy = 0
    for residue in input_sequence:
        total_hydropathy += AA_hydro[residue]
    input_mean_hydropathy = total_hydropathy / len(input_sequence)
    
    # figure out if current hydro is too high or too low and keep track
    input_greater_than = False
    input_less_than = False
    if input_mean_hydropathy > objective_hydro:
        input_greater_than = True
    else:
        input_less_than = True
    
    # figure out how much the hydro is off by 
    hydro_off_by = abs(objective_hydro - input_mean_hydropathy)

    # figure out where residues in the sequence can be changed
    all_possible_residue_coords = []
    for residue in range(0, len(input_sequence)):
        if use_charged == True:
            if input_sequence[residue] not in additional_exclusion:
                all_possible_residue_coords.append(residue)
        else:
            if input_sequence[residue] not in charged_residues and input_sequence[residue] not in additional_exclusion:
                all_possible_residue_coords.append(residue)

    # figure out location residues that can be changed that would actually move
    # the sequence hydropathy towards the objective hydropathy
    potential_change_residues_coords = []
    for potential_residue in all_possible_residue_coords:
        if input_greater_than == True:
            if AA_hydro[input_sequence[potential_residue]] > input_mean_hydropathy:
                potential_change_residues_coords.append(potential_residue)
        else:
            if AA_hydro[input_sequence[potential_residue]] < input_mean_hydropathy:
                potential_change_residues_coords.append(potential_residue)

    # if there are now residues identified as capable of changing, need to find something to change.
    if potential_change_residues_coords == []:
        if input_greater_than == True:
            best_val=10
            for residue in range(0, len(input_sequence)):
                if use_charged == True:
                    if input_sequence[residue] not in additional_exclusion:
                        potential_change_residues_coords.append(residue)
                else:
                    if input_sequence[residue] not in charged_residues and input_sequence[residue] not in additional_exclusion:
                        if AA_hydro[input_sequence[residue]] <= best_val:
                            potential_change_residues_coords.append(residue)
        else:
            best_val=0
            for residue in range(0, len(input_sequence)):
                if use_charged == True:
                    if input_sequence[residue] not in additional_exclusion:
                        potential_change_residues_coords.append(residue)         
                else:
                    if input_sequence[residue] not in charged_residues and input_sequence[residue] not in additional_exclusion:
                        if AA_hydro[input_sequence[residue]] >= best_val:
                            potential_change_residues_coords.append(residue)            

    # make list of possible residues to change the current residue to
    candidate_change_to_residues = []
    for residue in neutral_AAs:
        if input_greater_than == True:
            if residue not in additional_exclusion:
                if AA_hydro[residue] < input_mean_hydropathy:
                    candidate_change_to_residues.append(residue)
        else:
            if AA_hydro[residue] > input_mean_hydropathy:
                if residue not in additional_exclusion:
                    candidate_change_to_residues.append(residue) 

    # make list of final coordinates of amino acids to change
    final_candidate_coords = []
    # make list that holds residues that correspond to the positions for final_candidate_coords
    final_candidate_residues = []

    # figure out the best residue to change as far as keeping disorder
    # and staying within parameters
    for residue in potential_change_residues_coords:
        if input_greater_than == True:
            for potential_residues in candidate_change_to_residues:
                if ((AA_hydro[input_sequence[residue]] - AA_hydro[potential_residues])) <= hydro_off_by:
                    if input_sequence[residue] != potential_residues:
                        final_candidate_coords.append(residue)
                        final_candidate_residues.append(potential_residues)
        else:
            for potential_residues in candidate_change_to_residues:
                if (AA_hydro[potential_residues] - (AA_hydro[input_sequence[residue]])) >= hydro_off_by:
                    if input_sequence[residue] != potential_residues:
                        final_candidate_coords.append(residue)
                        final_candidate_residues.append(potential_residues)

    # if no candidates satisfy the condition, then just use the potential ones
    if final_candidate_coords == []:
        for residue_coord in potential_change_residues_coords:
            for candidate in candidate_change_to_residues:
                if input_sequence[residue_coord]!= candidate:
                    final_candidate_coords.append(residue_coord)
                    final_candidate_residues.append(candidate)


    # After all that we have two lists:
    # 1. the final_candidate_residues
    # 2. where they would go in the sequence (which is the final_candidate_coords list)

    # now going to figure out which is the best one to change
    # set best val to lowest possible value
    best_val = 0
    # keep track of best sequence
    best_sequence = ""

    # get candidate amino acids
    for potential_change in range (0, len(final_candidate_coords)):
        # get the current residue
        candidate = final_candidate_residues[potential_change]
        # set the current position
        position = final_candidate_coords[potential_change]

        # make the input sequence 
        # this depends on where the position of the AA of interest is
        if position == len(input_sequence)-1:
            tested_input_sequence = input_sequence[0:position] + candidate
        elif position == 0:
            tested_input_sequence = candidate + input_sequence[1:]
        else:
            tested_input_sequence = input_sequence[0:position] + candidate + input_sequence[position+1:]

        # calculate disorder values across whole sequence to account for how residue changes
        # other residues in the vicinity.
        disorder_val = sum(meta.predict_disorder(tested_input_sequence))

        if disorder_val > best_val:
            best_val = disorder_val
            best_sequence = tested_input_sequence

    # if there is not a best sequence just return the input sequence
    if best_sequence == "":
        best_sequence = input_sequence

    # return the sequence
    return best_sequence



def fast_optimize_hydro(input_sequence, objective_hydro, use_charged=True, additional_exclusion = []):
    """
    
    Function to take in a sequence that does not have the
    correct hydropathy and modify it to get the hydropathy 
    to become the correct value while maximizing predicted disorder.
    This is very similar to slow_optimize_hydro but instead of 
    explicitely predicting disorder, this uses the aa_dis_val dict
    which makes it much much faster. However, if it can't get the
    job done then the slow_optimize_hydro function can take
    care of it.

    Parameters
    -------------

    input_sequence : String
        The input sequence to optimize disorder for

    objective_hydro : Float
        The objective hydropathy value

    use_charged : Bool
        Whether or not to use charged residues as candidates

    additional_exclusion : List
        List of additional residues to exclude


    Returns
    ---------
        
    best_sequence : String
        A sequence with disorder / hydroathy further optimized

    """
    # list of charged residues
    charged_residues = ["D", "E", "K", "R"]
    # list of neutral amino acids
    neutral_AAs = ['A', 'C', 'F', 'G', 'H', 'I', 'L', 'M', 'N', 'P', 'Q', 'S', 'T', 'V', 'W', 'Y']
    # dict of hydropathy values
    AA_hydro = {"A": 6.3,
    "R": 0.0,
    "N": 1.0,
    "D": 1.0,
    "C": 7.0,
    "Q": 1.0,
    "E": 1.0,
    "G": 4.1,
    "H": 1.3,
    "I": 9.0,
    "L": 8.3,
    "K": 0.6,
    "M": 6.4,
    "F": 7.3,
    "P": 2.9,
    "S": 3.7,
    "T": 3.8,
    "W": 3.6,
    "Y": 3.2,
    "V": 8.7
    }

    # calculate current hydropathy
    total_hydropathy = 0
    for residue in input_sequence:
        total_hydropathy += AA_hydro[residue]
        
    # figure out the input mean hydropathy
    input_mean_hydropathy = total_hydropathy / len(input_sequence)
    
    # figure out if current hydro is too high or too low and keep track
    input_greater_than = False
    input_less_than = False
    
    # figure out if input is greater than or less than
    if input_mean_hydropathy > objective_hydro:
        input_greater_than = True
    else:
        input_less_than = True

    # figure out how much the hydro is off by 
    hydro_off_by = abs(objective_hydro - input_mean_hydropathy)

    # figure out where residues in the sequence can be changed
    all_possible_residue_coords = []
    for residue in range(0, len(input_sequence)):
        if use_charged == True:
            if input_sequence[residue] not in additional_exclusion:
                all_possible_residue_coords.append(residue)
        else:
            if input_sequence[residue] not in charged_residues and input_sequence[residue] not in additional_exclusion:
                all_possible_residue_coords.append(residue)

    # figure out location residues that can be changed that would actually move
    # the sequence hydropathy towards the objective hydropathy
    potential_change_residues_coords = []
    for potential_residue in all_possible_residue_coords:
        if input_greater_than == True:
            if AA_hydro[input_sequence[potential_residue]] > input_mean_hydropathy:
                potential_change_residues_coords.append(potential_residue)
        else:
            if AA_hydro[input_sequence[potential_residue]] < input_mean_hydropathy:
                potential_change_residues_coords.append(potential_residue)


    # if there are now residues identified as capable of changing, need to find something to change.
    if potential_change_residues_coords == []:
        if input_greater_than == True:
            best_val=10
            for residue in range(0, len(input_sequence)):
                if use_charged == True:
                    if input_sequence[residue] not in additional_exclusion:
                        potential_change_residues_coords.append(residue)
                else:
                    if input_sequence[residue] not in charged_residues and input_sequence[residue] not in additional_exclusion:
                        if AA_hydro[input_sequence[residue]] <= best_val:
                            potential_change_residues_coords.append(residue)
        else:
            best_val=0
            for residue in range(0, len(input_sequence)):
                if use_charged == True:
                    if input_sequence[residue] not in additional_exclusion:
                        potential_change_residues_coords.append(residue)         
                else:
                    if input_sequence[residue] not in charged_residues and input_sequence[residue] not in additional_exclusion:
                        if AA_hydro[input_sequence[residue]] >= best_val:
                            potential_change_residues_coords.append(residue)            


    # make list of possible residues to change the current residue to
    candidate_change_to_residues = []
    for residue in neutral_AAs:
        if input_greater_than == True:
            if residue not in additional_exclusion:
                if AA_hydro[residue] < input_mean_hydropathy:
                    candidate_change_to_residues.append(residue)
        else:
            if AA_hydro[residue] > input_mean_hydropathy:
                if residue not in additional_exclusion:
                    candidate_change_to_residues.append(residue) 

    # make list to hold coordinates for final canddidates
    final_candidate_coords = []
    # make list that holds residues that correspond to the positions for final_candidate_coords
    final_candidate_residues = []

    # figure out the best residue to change as far as keeping disorder
    # and staying within parameters
    for residue in potential_change_residues_coords:
        if input_greater_than == True:
            for potential_residues in candidate_change_to_residues:
                if ((AA_hydro[input_sequence[residue]] - AA_hydro[potential_residues])) <= hydro_off_by:
                    if input_sequence[residue] != potential_residues:
                        final_candidate_coords.append(residue)
                        final_candidate_residues.append(potential_residues)
        else:
            for potential_residues in candidate_change_to_residues:
                if (AA_hydro[potential_residues] - (AA_hydro[input_sequence[residue]])) >= hydro_off_by:
                    if input_sequence[residue] != potential_residues:
                        final_candidate_coords.append(residue)
                        final_candidate_residues.append(potential_residues)

    # if no candidates satisfy the condition, then just use the potential ones
    if final_candidate_coords == []:
        for residue_coord in potential_change_residues_coords:
            for candidate in candidate_change_to_residues:
                if input_sequence[residue_coord]!= candidate:
                    final_candidate_coords.append(residue_coord)
                    final_candidate_residues.append(candidate)


    # After all that we have two lists:
    # 1. the final_candidate_residues
    # 2. where they would go in the sequence (which is the final_candidate_coords list)

    # set best val to lowest possible value
    best_val = 0
    # keep track of best sequence
    best_sequence = ""

    # list of amino acids in order from aa_dis_val dict creation
    amino_acids = ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y']

    # get candidate amino acids
    for potential_change in range (0, len(final_candidate_coords)):
        # get the current residue
        candidate = final_candidate_residues[potential_change]
        # set the current position
        position = final_candidate_coords[potential_change]

        # make the input sequence 
        # this depends on where the position of the AA of interest is
        if position == len(input_sequence)-1:
            tested_input_sequence = input_sequence[0:position] + candidate
        elif position == 0:
            tested_input_sequence = candidate + input_sequence[1:]
        else:
            tested_input_sequence = input_sequence[0:position] + candidate + input_sequence[position+1:]

        # set total disorder to 0
        total_disorder = 0
        
        # get the current index of the amino acid
        cur_index = amino_acids.index(candidate)

        # iterate over the length of the tested input sequence
        for i in range(0, len(tested_input_sequence)-4):
            cur_seq = tested_input_sequence[i:i+4]
            four_amino_acids_key = optimal_residue_key(cur_seq)
            potential_AA_vals = aa_dis_val_4_v3[four_amino_acids_key]
            cur_dis_val = potential_AA_vals[cur_index]
            total_disorder += cur_dis_val

        # if the total disorder is greater than the best
        if total_disorder > best_val:
            # overwrite the best value
            best_val = total_disorder
            # overwrite the best seuqence
            best_sequence = tested_input_sequence

    # if no best sequence just set best_sequence to input_sequence
    if best_sequence == "":
        best_sequence = input_sequence

    # return the sequence
    return best_sequence




def optimize_disorder(input_sequence, exclude = [], cutoff_val=0.7, hold_start_codon=False):
    """
    
    Function to optimize the disorder of an input sequence.
    This function is not very fast and only prioritizes disorder.
    Therefore, in it might alter hydropathy values when optimizing 
    sequences with specified hydropathy. However, it is still extremely
    useful as you can follow further hydropatyh optimzations with this
    disorder optimization to get your final sequence just right.


    Parameters
    -------------

    input_sequence : String
        The input sequence to optimize disorder for

    exclude : List
        The list of residues to be excluded from optimziaton

    cutoff_val : Float
        cutoff value to be used for considering something to be disordered

    hold_start_codon : Bool
        Whether or not there is a start codon that needs to be kept in place


    Returns
    ---------
        
    modified_input_sequence : String
        A sequence with disorder further optimized

    """

    # list of amino acids
    amino_acids = ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y']
    
    # figure out which amino acids can be tested to replace others in the sequence
    test_these_residues = []
    for aa in amino_acids:
        if aa not in exclude:
            test_these_residues.append(aa)

    # identify regions that need to be altered
    input_disorder = meta.predict_disorder(input_sequence)

    # make list of regions to alter
    ordered_regions = []

    # figure out range of residues that can be modified based on if
    # the start codon needs to be held in place
    if hold_start_codon == False:
        start_of_range = 0
    else:
        start_of_range = 1

    # identify ordered residues in the rnage
    for i in range(start_of_range, len(input_disorder)):
        if input_disorder[i] < cutoff_val:
            if input_sequence[i] not in exclude:
                ordered_regions.append(i)

    # if nothing below cutoff_val, just return the sequence
    if ordered_regions == []:
        return input_sequence

    else:
        # choose targets to modify. 
        target_regions=[]
        
        # choose a random residue to target to avoid picking the same residue over and over
        chosen_number = ordered_regions[random.randint(0, len(ordered_regions)-1)]
        target_regions.append(chosen_number)

        # figure out the poteintial disorder values at each region
        target_values = []
        for target in target_regions:
            if input_sequence[target] in test_these_residues:
                test_these_residues.remove(input_sequence[target])
                values = all_scores_at_position(input_sequence, target, try_residues=test_these_residues)
                test_these_residues.append(input_sequence[target])
            else:
                values = all_scores_at_position(input_sequence, target, try_residues=test_these_residues)
            target_values.append(values)


        # making empty string to make sure that I'm actually getting something out.
        modified_input_sequence = ""

        # figure out the best value to add to each position
        for value in range(0, len(target_values)):
            cur_target_values = target_values[value]
            best_value = 0
            best_coordinate = 0
            best_residue = ""
            for score in range(0, len(cur_target_values[1])):
                cur_value = (cur_target_values[1][score])
                if cur_value > best_value:
                    best_value = cur_value
                    best_coordinate = score
                    best_residue = cur_target_values[0][score]
            
            # update sequence
            cur_target_location = target_regions[value]

            # make the input sequence 
            # this depends on where the cur_target_location of the AA of interest is
            if cur_target_location == len(input_sequence)-1:
                modified_input_sequence = input_sequence[0:cur_target_location] + best_residue
            elif cur_target_location == 0:
                modified_input_sequence = best_residue + input_sequence[1:]
            else:
                modified_input_sequence = input_sequence[0:cur_target_location] + best_residue + input_sequence[cur_target_location+1:]
            
            # overwrite value of input sequence
            input_sequence = modified_input_sequence
        
        # return the optimized seqeunce
        return modified_input_sequence


def optimize_charge_asymmetry(sequence, objective_charge_asymmetry, cutoff, iterations = 20):

    """
    
    Function to optimize charge asymmetry of an input sequence
    to some objective value.

    Parameters
    -------------

    sequence : String
        The amino acid sequence as a string.

    objective_charge_asymmetry : Float
        The objective charge asymmetry value
        More negative generally means more asymmetric

    cutoff : Float
        Cutoff value for disorder

    iterations : Int
        Number of times to try to make the sequence before giving up.


    Returns
    ---------
        
    sequence : String
        Returns an amino acid sequence with an increased charge asymmetry

    """


    starting_charge_asymmetry = Protein(sequence).SCD

    # figure out current error
    starting_error = abs(starting_charge_asymmetry - objective_charge_asymmetry)

    # see if error is out of desired range
    if starting_error > 0.5:
        # set current best error to starting error
        current_best_error = starting_error
        # set input optimized sequence equal to sequence
        input_sequence = sequence
        # set current best sequence equal to sequence
        current_best_sequence = sequence

        # set charge optimizations to zero
        charge_optimizations = 0

        # go about iterations
        while charge_optimizations <  iterations:

            current_charge_asymmetry = Protein(input_sequence).SCD 

            # figure out if to increase or decrease charge asymetry
            if objective_charge_asymmetry > current_charge_asymmetry:
                new_sequence = decrease_charge_asymmetry(input_sequence, cutoff=cutoff)
                if new_sequence == "Unable to decrease charge asymetry without reducing disorder below threshold.":
                    new_sequence = current_best_sequence

            else:
                new_sequence = increase_charge_asymmetry(input_sequence, cutoff=cutoff)
                if new_sequence == "Unable to increase charge asymetry without reducing disorder below threshold.":
                    new_sequence = current_best_sequence 

            # figure out how the new sequence is doing
            new_sequence_asymetry = abs(Protein(new_sequence).SCD - objective_charge_asymmetry)

            # overwrite best of new is better
            if new_sequence_asymetry < current_best_error:
                current_best_error = new_sequence_asymetry
                input_sequence = new_sequence
                current_best_sequence = new_sequence

            if new_sequence_asymetry < 0.5:
                charge_optimizations += iterations

            charge_optimizations += 1

        return current_best_sequence

    else:
        return sequence



def gen_minimal_sequence_variant(input_sequence, mean_hydro = '', fraction = '', net_charge = '', charge_asymmetry='', cutoff=parameters.DISORDER_THRESHOLD, strict=False):

    '''
    tries to change the paramters you want 
    while minimally changing the starting sequence
    '''

    sequence = ""
    for i in input_sequence:
        sequence+=i

    # clean up the input sequence
    input_sequence = cleanup_sequence(input_sequence)

	# check for out of bounds ncpr

    if fraction == '':
    	if net_charge != '':
    		if abs(net_charge) > Protein(sequence).FCR:
    			raise GooseInputError('The specified value for net_charge is not possible with the FCR value of the input sequence. Please increase fraction or decrease net_charge.')

    # make sure that properties not specified are set to stay the same
    if mean_hydro == '':
        mean_hydro = Protein(sequence).hydropathy

    if fraction == '':
        fraction = Protein(sequence).FCR

    if net_charge == '':
        net_charge = Protein(sequence).NCPR

    # keep track of original disorder
    original_disorder = meta.predict_disorder(input_sequence)

    # keep track of length
    length = len(input_sequence)


    #        Figure out charge stuff
    #=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#  

    # figure out total number of positive/negative charged residues in input sequence
    input_negative_residues = sequence.count('E') + sequence.count('D')
    input_positive_residues = sequence.count('K') + sequence.count('R')

    # get total charged reisudes
    input_charged_residues = input_negative_residues + input_positive_residues

    # figure out objective number of charged residues
    objective_total_charge = fraction * length

    # figure out objective net_charge
    objective_net_charge = net_charge * length


    # figure out how many charged residues (to remain neutral) are needed
    needed_neg_and_pos = round(objective_total_charge - abs(objective_net_charge))/2

    # figure out number of neg and pos separately
    if objective_net_charge < 0:
        needed_negative = needed_neg_and_pos + abs(objective_net_charge)
        needed_positive = needed_neg_and_pos
    elif objective_net_charge > 0:
        needed_negative = needed_neg_and_pos
        needed_positive = needed_neg_and_pos + objective_net_charge
    else:
        needed_negative = needed_neg_and_pos
        needed_positive = needed_neg_and_pos


    #           removing charged residues if needed
    #=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#

    # list of random positions to remove
    remove_these_positions = []

    # start adjusting sequence if you need to remove charged residues
    if needed_negative < input_negative_residues:
        # make list to hold negative charged residue locations
        neg_charged_residue_locations = []
        for i in range(0, len(sequence)):
            cur_AA = sequence[i]
            if cur_AA == "D" or cur_AA == "E":
                neg_charged_residue_locations.append(i)

        # add random locations to the remove_these_positions list
        for i in range(0, int(abs(needed_negative - input_negative_residues))):
            if len(neg_charged_residue_locations)>1:
                number_index = random.randint(0, len(neg_charged_residue_locations)-1)
            else:
                number_index = 0
            remove_these_positions.append(neg_charged_residue_locations.pop(number_index))

    if needed_positive < input_positive_residues:
        # make list to hold negative charged residue locations
        pos_charged_residue_locations = []
        for i in range(0, len(sequence)):
            cur_AA = sequence[i]
            if cur_AA == "K" or cur_AA == "R":
                pos_charged_residue_locations.append(i)
        for i in range(0, int(abs(needed_positive - input_positive_residues))):
            if len(pos_charged_residue_locations)>1:
                number_index = random.randint(0, len(pos_charged_residue_locations)-1)
            else:
                number_index = 0
            remove_these_positions.append(pos_charged_residue_locations.pop(number_index))


    if remove_these_positions != []:
        for i in remove_these_positions:
            if i == 0:
                new_sequence = random_amino_acid(neutral_IDR_list) + sequence[1:]
            elif i == len(sequence):
                new_sequence = sequence[0:len(sequence)] + get_optimal_residue(sequence[i-4:], exclude_residues = ['D', 'E', 'K', 'R', 'P'])
            else:
                sequence_chunk = sequence[0:i]
                if len(sequence_chunk) > 4:
                    new_sequence = sequence[0:i] + get_optimal_residue(sequence[i-4:i], exclude_residues = ['D', 'E', 'K', 'R', 'P']) + sequence[i+1:]
                else:
                    new_sequence = sequence[0:i] + random_amino_acid(neutral_IDR_list) + sequence[i+1:]
            # overwrite with new sequence
            sequence = new_sequence


    #      adding charged residues if needed
    #=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#    

    # dict of AA hydro values
    AA_hydro = {"A": 6.3, "R": 0.0, "N": 1.0, "D": 1.0, "C": 7.0, "Q": 1.0, "E": 1.0, "G": 4.1, "H": 1.3, "I": 9.0, "L": 8.3, "K": 0.6, "M": 6.4, "F": 7.3, "P": 2.9, "S": 3.7, "T": 3.8, "W": 3.6, "Y": 3.2, "V": 8.7}
    
    # first for negative residues
    if needed_negative > input_negative_residues:
        difference = int(needed_negative-input_negative_residues)
        for i in range(0, difference):
            current_sequence_hydropathy = Protein(sequence).hydropathy

            if current_sequence_hydropathy > mean_hydro:               
                best_position = 0
                best_hydropathy = 0           
                for i in range(0, len(sequence)):
                    cur_AA = sequence[i]
                    if cur_AA not in charged_list:
                        if AA_hydro[cur_AA] > best_hydropathy:
                            best_position = i
                            best_hydropathy = AA_hydro[cur_AA]
            else:
                best_position = 0
                best_hydropathy = 100   
                for i in range(0, len(sequence)):
                    cur_AA = sequence[i]
                    if cur_AA not in charged_list:
                        if AA_hydro[cur_AA] < best_hydropathy:
                            best_position = i
                            best_hydropathy = AA_hydro[cur_AA]

            # now delete the residue and add in a D/E
            if best_position == 0:
                new_sequence = random_amino_acid(D_E) + sequence[1:]
            elif best_position == len(sequence):
                new_sequence = sequence[0:len(sequence)] + random_amino_acid(D_E)
            else:
                new_sequence = sequence[0:best_position] + random_amino_acid(D_E) + sequence[best_position+1:]
            # now overwrite sequence with new_sequence
            sequence = new_sequence

    # now for positive residues
    if needed_positive > input_positive_residues:
        difference = int(needed_positive-input_positive_residues)
        for i in range(0, difference):
            current_sequence_hydropathy = Protein(sequence).hydropathy
            
            if current_sequence_hydropathy > mean_hydro:               
                best_position = 0
                best_hydropathy = 0
                for i in range(0, len(sequence)):
                    cur_AA = sequence[i]
                    if cur_AA not in charged_list:
                        if AA_hydro[cur_AA] > best_hydropathy:
                            best_position = i
                            best_hydropathy = AA_hydro[cur_AA]
            else:
                best_position = 0
                best_hydropathy = 100                
                for i in range(0, len(sequence)):
                    cur_AA = sequence[i]
                    if cur_AA not in charged_list:
                        if AA_hydro[cur_AA] < best_hydropathy:
                            best_position = i
                            best_hydropathy = AA_hydro[cur_AA]

            # now delete the residue and add in a D/E
            if best_position == 0:
                new_sequence = random_amino_acid(K_R) + sequence[1:]
            elif best_position == len(sequence):
                new_sequence = sequence[0:len(sequence)] + random_amino_acid(K_R)
            else:
                new_sequence = sequence[0:best_position] + random_amino_acid(K_R) + sequence[best_position+1:]
            # now overwrite sequence with new_sequence
            sequence = new_sequence
            
    #      altering hydropathy as needed
    #=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#    

    error = abs(Protein(sequence).hydropathy-mean_hydro)

    if error > parameters.HYDRO_ERROR:        
        attempted_optimization = 0
        number_iterations = len(sequence)
        # start initial optimizations
        prev_seqs = []
        while attempted_optimization < number_iterations:
            optimized_sequence = fast_optimize_hydro(sequence, mean_hydro, use_charged=False, additional_exclusion='P')
            sequence = optimized_sequence
            # see if this is getting repetetive
            if sequence in prev_seqs:
                attempted_optimization += number_iterations * 2

            prev_seqs.append(sequence)            
            attempted_optimization = attempted_optimization + 1

            if abs(Protein(sequence).hydropathy-mean_hydro) < parameters.HYDRO_ERROR:
                attempted_optimization += number_iterations * 2

    #  Bringing out the slow optimizer if needed
    #=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#    

    error = abs(Protein(sequence).hydropathy-mean_hydro)

    if error > parameters.HYDRO_ERROR:          
        attempted_optimizations = 0
        number_iterations = len(sequence)
        # start initial optimizations
        while attempted_optimization < number_iterations:
            optimized_sequence = slow_optimize_hydro(sequence, mean_hydro, use_charged=False, additional_exclusion='P')
            sequence = optimized_sequence
            # see if this is getting repetetive
            if sequence in prev_seqs:
                attempted_optimization += number_iterations * 2

            prev_seqs.append(sequence)            
            attempted_optimization = attempted_optimization + 1

            if abs(Protein(sequence).hydropathy-mean_hydro) < parameters.HYDRO_ERROR:
                attempted_optimization += number_iterations * 2


    if sequence_variant_disorder(sequence, original_disorder, cutoff=cutoff, strict=strict) == False:

        # get sequence disorder
        sequence_disorder = meta.predict_disorder(sequence)
        # figure out how many residues have disorder value above the cutoff
        number_ordered_residues = 0
        for dis_val in sequence_disorder:
            if dis_val < cutoff:
                number_ordered_residues += 1

        # do some optimization
        if number_ordered_residues > 0:
            # keep track of current iteration
            current_iteration = 0
            
            while current_iteration < (number_ordered_residues * 2):
                
                # optimize the sequence
                new_sequence = optimize_disorder(sequence, exclude=['D', 'E', 'K', 'R', 'P'])
                if sequence_variant_disorder(sequence, original_disorder, cutoff=cutoff, strict=strict) == True:
                    sequence = new_sequence
                    current_iteration = current_iteration + (number_ordered_residues * 3)

                # set sequence equal to new_sequence
                sequence = new_sequence 

                # add 1 to the current iterations 
                current_iteration = current_iteration + 1

    if sequence_variant_disorder(sequence, original_disorder, cutoff=cutoff, strict=strict) == False or abs(Protein(sequence).hydropathy - mean_hydro) > parameters.HYDRO_ERROR:
        
        # do some fast optimizations
        cur_iteration = 0
        max_iterations = 100
        while cur_iteration < max_iterations:
            optimized_seq = fast_optimize_hydro(sequence, mean_hydro, use_charged=False)
            sequence = optimized_seq
            if abs(Protein(sequence).hydropathy - mean_hydro) < parameters.HYDRO_ERROR:
                cur_iteration += 100
            cur_iteration += 1
            

    if abs(Protein(sequence).hydropathy - mean_hydro) > parameters.HYDRO_ERROR:
        cur_slow_iteration = 0
        max_slow_iterations = 5
        while cur_slow_iteration < max_slow_iterations:
            optimized_seq = slow_optimize_hydro(sequence, mean_hydro, use_charged=False)
            if abs(Protein(sequence).hydropathy - mean_hydro) < parameters.HYDRO_ERROR:
                return sequence
                cur_slow_iteration += 100
            cur_slow_iteration += 1

    if charge_asymmetry != '':
        cur_charge_asymmetry = Protein(sequence).SCD
        if abs(cur_charge_asymmetry - charge_asymmetry) > 0.5:
            sequence = optimize_charge_asymmetry(sequence, charge_asymmetry, cutoff=cutoff, iterations=100)


    if sequence_variant_disorder(sequence, original_disorder, cutoff=cutoff, strict=strict) == True:
        if abs(Protein(sequence).hydropathy-mean_hydro) < parameters.HYDRO_ERROR:
            return sequence

    raise GooseFail('Unable to generate sequence.')


