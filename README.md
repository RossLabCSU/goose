![GOOSE_LOGO_FULL](https://github.com/ryanemenecker/goose/blob/main/images/goose_logo_3.png) 
# GOOSE : Generate disOrdered prOtiens Specifying propErties

## What is GOOSE?
GOOSE is a python package developed to make the generation of IDRs with specific properties or the generation of IDR variants easy. This was the original goal, but some of the functionality has expanded into other areas such as generating sequences that have predicted secondary structure. Basically, we want to make it easy for you to design IDRs or IDR variants for your research. GOOSE currently only works from Python, but a CLI is in the works. 

### A quick note - 
This is the first public release of GOOSE. While we have done extensive testing on the functionality, due to the massive sequence space that is possible when generating an IDR, you may encounter bugs. We would appreciate if you would report these bugs. Furthermore, **it is best practice to double check that the sequence generated by GOOSE is the sequence you intended to make**. You can do this using the ***analyze*** module included with GOOSE. 

We are also very excited to hear from you about any feature requests! Please email me at remenecker@wustl.edu with the subject line **GOOSE feature request** and I'll be happy to see if I can make it happen. My goal is to make this *as useful as possible to the protein disorder community*.

## Why was GOOSE made?

It is rather difficult to know which properties of any given intrinsically disordered region (IDR) are important for its function. Is it the hydropathy? Maybe the fraction of charged residues? Who knows? Further, generating IDR variants can be a tricky task. Sure, you can swap all of one residue for another or make large truncations in your IDR, but there are limitations to those and similar approaches. This is why we made GOOSE. GOOSE lets you generate IDRs or IDR variants based on an IDR that you are interested in to figure out which properties of your IDR of interest are important for its function. 

## What all can GOOSE do?

There are four main functionalities currently in GOOSE. 

**1.** GOOSE can let you generatae IDRs where you can specify the properties *length*, *average hydropathy*, *fraction of charged residues (FCR)*, *net charge per residue (NCPR)*, and *kappa*, which is a property that defines charge separation in a sequence. These properties are all very important for the biophysical behavior of any IDR! 

**2.** GOOSE can let you generate IDR variants. The different variants I currently have implemented should allow you to address many questions you might be interested in by letting you choose which parts of your IDR to hold constant. Importantly, most of the variant generators **keep the overall properties of your IDR constant**. This means that you can generate numerous sequences with the same overall properties but differing in various different ways to really narrow down on *what makes your IDR of interest work*? More on the variants later though.

**3.** GOOSE can let you generate sequences **predicted** to form secondary structures including alpha helices, beta strands, and beta sheets. Wait! GOOSE is for IDRs?! Fair point! However, because IDRs can interact with folded domains, this might be a feature that allows you to carefully investigate how an IDR of interest is impacted by the presence of, for example, a large beta sheet. I'm also working on making it so you can control some properties (like hydropathy) of these sequences, but that's proven to be a bit challenging and will be coming (hopefully) in the near future.

**4.** GOOSE comes with a bunch of sequence analysis tools. This is for a few reasons. First, sometimes it's nice to just analyze an IDR you're interested in before making variants. It's good to know whether your IDR may have a transcriptional activation domain or a phosphosite. Additionally, it allows you to analyze the IDRs you generate using GOOSE to make sure you don't accidentally send it to the nucleus or something of the sort due to GOOSE adding an NLS to your sequence during sequence generation.

**5.** GOOSE lets you make sequence libraries. This is currently under development, so it is currently limited to generating sequence libraries by sequence properties. 

## How can I use GOOSE?

**GOOSE is a Python API only.** I am also working on making a Google Colab notebook to make it as easy as possible for anyone to generate their own sequences or sequence variants, but that is still in development.

## Installing GOOSE - GOOSE takes flight!

Right now you can only install GOOSE through Github. It will be on PyPi to allow for pip installation soon!

To install directly from the git repository simply run:

	$ pip install git+https://github.com/idptools/goose.git

Or to clone the GitHub repository and install locally run - 

	$ git clone https://github.com/idptools/goose.git
	$ cd goose
	$ pip install .

**Important note**

*AFTER you install GOOSE*, you will also need to install SPARROW (another package we are working on that is not yet on PyPi). I promise we will make this easier in the near future, but for now you will also need to run the following:

	$ pip install git+https://github.com/holehouse-lab/sparrow.git


This will install SPARROW. **Important note**: if your attempted install of SPARROW fails, it may be because you do not have numpy or cython installed. I made them both required for installation of GOOSE, so if you install GOOSE first, you should be ok. If you still have problems, try running from terminal:

	$ pip install cython
	$ pip install numpy

Sorry this is a pain, we promise we will make it better shortly!!!

# Time to leave the nest - how to use GOOSE from Python

## Sequence Generation

GOOSE allows you to easily generate sequences. GOOSE verifies disorder ofthe generated sequence using metapredict V2 before returning it to you. The default cutoff disorder is 0.6, which is fairly strict. However, you can alter this if you'd like. For example, if you're having a hard time making a sequence, it may be worth reducing the threshold to the normal metapredict V2 threshold of 0.5.

## Some important limitations to be aware of

**A quick note on discrepencies between input properties and the actual values of generated sequences**. GOOSE by default allows a small amount of error for hydropathy (it is allowed to be off by 0.05, which is honestly negligible) and for kappa (it is allowed to be off by 0.02). This is basically a balance between accuracy and speed. If you go into goose/backend/properties, you can modify these properties globally if you install GOOSE locally. Finally, if you choose an NCPR / FCR combination that is mathematically impossible, GOOSE will get as close as it can.


### An important note on the speed of sequence generation

The protein disorder field is not a slow moving one, and we are not here to slow you and your research down. Therefore, it was important for us to make GOOSE as fast as possible. However, because GOOSE incorporates stochasticity into sequence generation (see below for more on that), GOOSE still has to do some work when designing your disordered sequence. Importantly *the more properties you specify, or the more constraints you put on sequence design, the more time it will take GOOSE to generate your sequence*. 

 
### Stochasticity of sequences generated using GOOSE

Making a sequence generator to generate IDRs is not a challenging problem provided you simply choose the most disordered residue possible at each step. However, that would result in the same sequence being generated over and over again, which massively limits the utility of the sequence generator. We designed GOOSE to have a bit of stochasticity in that it will *generally* not make the same sequence twice. For example, when we made 100,000 sequences that were 100 amino acids in length using GOOSE, every single sequence was unique. However, we want to emphasize that *the more properties you specify when making sequences, the less available sequence space there is for GOOSE to explore. This will increase the chance that GOOSE will make the same sequence twice*. This is generally not a problem, but it is something that we wanted users to be aware of.

*An important exception to this rule is the ``create.minimal_var()`` function because it attempts to change as little of the input sequence as possible and therefore will frequently return the same sequenece multiple times.*


### An important note on failed sequence generation

Sometimes GOOSE can't make your sequence. We did our best to make sure that you will not run across a situation where this occurs, but with the enormous amount of possible different combinations of properties and sequence properties, it is possible that GOOSE will be unable to make something you would like. This can often be easily overcome by *slightly* adjusting your properties or reducing the cutoff value (the cutoff value is the value required for something to be considered disordered). You can also just make GOOSE try to make your sequence a few more times, GOOSE will often eventually get something that works (thanks to the inherent stochasticity in sequence generation).


### Incompatible FCR, NCPR, and hydropathy values

GOOSE uses a rescaled Kyte Doolittle hydropathy scale for calculating mean hydropathy. This scale goes from 0 to 9 where higher values are more hydrophobic.  Importantly, each amino acid has a specific value associated with it. For example, isoleucine (I) has a value of 9 and arginine (R) has a value of 0. The charged residues have low hydropathy values (R = 0, K = 0.6, D = 1, E = 1). Therefore, if you have a sequence with too many charged residues, you limit how high the mean hydropathy can possibly go for a sequence. If you specify a high FCR and a high hydropathy, that sequence may be mathematically impossible to make. GOOSE will return an error if you do this. In addition, there is a limited sequence space of charge / hydropathy combinations that are predicted to be disordered. I have empirically determined the limits of FCR values associated with hydropathy values for GOOSE, and GOOSE will not let you cross that limit when designing sequences. 


### Limits on mean hydropathy**

The more hydrophobic a sequence, the less likely it is to be predicted to be disordered *generally speaking*. The higher the mean hydropathy value, the harder time GOSE will have in making the sequence.


# Using GOOSE from within Python

To use GOOSE from within Python, first import *create from goose*

    from goose import create

Once *create* has been imported, you can start making seqeunces and sequence variants!

## Generating sequences with specified sequence properties

The ``create.sequence()`` function lets you create sequences predicted to be disordered with various specified properties. 

The only required argument is the length, which must be between 10 and 10,000. In addition, you can also specify several design parameters.

1. `hydropathy`: Hydropathy, which must be between 0 and 6.1.

2. `FCR`: The fraction of charged residues, which must be between 0 and 1

3. `NCPR`: The net charge per residue (`NCPR`), which must be between -1 and +1

4. `kappA`: The kappa value, a charge asymmetry parameter where higher values mean greater charge asymmetry. This must be between 0 and 1.

5. `sigma`: An alternative charge asymmetry parameter, although if you specify sigma **you cannot specify other properties**, between 0 and 1.

In addition to these parameters, you can specify a few additional parameters:

1. `cutoff`:  The disorder cutoff used defines a threshold GOOSE uses to selected/reject sequences. A higher cutoff means higher confidence that the sequence is disordered. The default value is 0.6. If you have difficulty making your sequence, you might want to try lowering the cutoff value.

2. `attempts`: The number of attempts defines how many times GOOSE will try to generate a desired sequence. This is relevant because certain parameter combinations of values are more challenging than others, and GOOSE implements a stochastic design algorithm such that different sequences are generated every time. For harder sequence compositions you may need to increase this from the default value of 100. 

**Importantly, you do not need to specify all of these sequence properties simultaneously.** For example, if you specify FCR and hydropathy, GOOSE will return sequences that have varying NCPR values while making sure that the specified hydropathy and FCR values are what you input. In this way, you can generate many sequences that have the fixed properties that you want to stay fixed, while other properties can vary. Alternatively, if you need to specify values for all properties, you can do that too!

#### Examples

Just specifying sequence length:

    create.sequence(40)
    'GDHNKAGQPPRKCSDQGGAGAPNPDCDPDTAPMDGDRMTN'


Specifying length and hydropathy:

    create.sequence(100, hydro = 3)
    'MTSYGRDGSPETGEGSTGTNSSSSRSMMGSTHNWQQYNGGTTSGTSSTGDSHRTHGDHSAGETTSGGDSEGTDETSTTTNGRGSSSGHDGSTGQDTNTRR'

Hydropathy values can be between 0.0 and 6.1. **Note**: the higher the hydropathy *over 5*, the longer it will take GOOSE to generate the sequence. Sequences that are very hydrophobic and disordered can be tricky to make. **Note**: whenever specifying hydropathy values, GOOSE will return a sequence within 0.05 of the specified value! This amount of error helps keep GOOSE fast (and a difference of 0.05 is typically negligible).

**Specifying length and fraction of charged residues (FCR):**

    create.sequence(40, FCR = 0.3)
    'GDRPSEHGQGPRKEDGMDQDDVSTEGHEWSNNPCNQSNNP'

FCR values can be between 0 and 1

**Specifying length and the net charge per residue (NCPR):**

    create.sequence(40, NCPR = -0.2)
    'MQKNDRAPDHKDREKDGPIKERPEECPDDEQSDDEECPSH'

NCPR values can be between -1 and 1.

**Specifying length and sigma:**

    create.sequence(40, sigma = 0.3)
    'EKDKMEETHDDEGMQQDNNTETDEQPDNYESNDDEHATEG'

sigma values can be between 0 and 1.

 
**Specifying multiple properties**

GOOSE lets you combine different properties simultaneously. Importantly, any value you do not specify will just be random.

**Note**: Simultaneously specifying high hydropathy values and a high FCR is challenging and may be slow! In addition, because the hydropathy values of charged residues are very low (K=0.6, R = 0, D and E = 1), it is impossible to make sequences with too high of an FCR and too high of a hydropathy value. 

**Examples**

**FCR & NCPR**

    create.sequence(100, FCR = 0.3, NCPR = -0.1)
    'TSNQDKEMPQQHSPRCQPGEKVSDPPRSSDNSTNGGARPQQDWRPPEHMNPNRYEPNTMHQNREGRESAGGKDWPNPTIDQNQDPHEDTDNQEEESDHPC'

You cannot have values for NCPR where the absolute value of NCPR is greater than the specified FCR value. For example, NCPR = 0.4, FCR = 0.2 will not work (you can't get a net charge of 0.4 with only 0.2 fraction of charged residues!)

**Important note on combining FCR and NCPR!** Whenever NCPR and FCR are combined, if the combinations of the length, NCPR, and FCR are not mathematically possible, GOOSE will get as close as it can. In addition, GOOSE  prioritizes NCPR over FCR, and the resulting sequence may deviate in terms of FCR as a result.

**FCR & Hydropathy**

    create.sequence(100, FCR = 0.3, hydro = 3.2)
    'KVDSGTTSCSGERESDSGDLKSSKEGSSGSGSSSKSSKSKEATGSSTDTTAAAGGKGGGGGGDGGKGDGRGKGGGGGGEGRDGGGGGGEGGRGGGGRKRD'

When specifying hydropathy with FCR or NCPR, the max possible hydropathy value is 5.8. In addition, after extensive testing, I found that sequences with high hydropathy values and high FCR values will never be predicted to be disordered by metapredict. Therefore, I restricted the ability to input these property combinations (no sense being stuck waiting for a sequence to be generated that will never actually end up generated). In general, the maximum possible FCR value will equal (hydro x -0.2289)+1.2756.

**NCPR & Hydropathy**

    create.sequence(100, NCPR = -0.3, hydro = 2.4)
    'REARGDAKGERDRGGDAKDKGAESGKDDDGEEEGAGEEEGEEGDDEAEADRADKERAERDKGDRDRAEGRAEKGAAAAEGADEGADEADEEEDDDADDEE

When specifying hydropathy with FCR or NCPR, the max possible hydropathy value is 5.8.


**NCPR, FCR, & Hydropathy**

    create.sequence(100, hydro = 2.65, NCPR = -0.3, FCR = 0.4)
    'NETPARPETHRDTASTSEGDETSEPEGTWSSNEADTDDDAETEHSPMSEDGERCESSKDAPPMRDEEGDDEDVEDTPDVSSSPDYEPGGHYSESNNDWPD'

This function has the same limitations as FCR & hydropathy or NCPR & hydropathy. It's important to note that **the more properties you specify, the longer it might take GOOSE to make the sequence**. In addition, longer sequences tend to take greater amounts of time to generate.


**NCPR, FCR, Hydropathy, and kappa**

    create.sequence(100, hydro = 2.65, NCPR = 0.0, FCR = 0.4, kappa=0.2)
    'NETPARPETHRDTASTSEGDETSEPEGTWSSNEADTDDDAETEHSPMSEDGERCESSKDAPPMRDEEGDDEDVEDTPDVSSSPDYEPGGHYSESNNDWPD'


### Generating sequences by specifying fractions of amino acids in Python

The ``create.seq_fractions()`` function lets you create sequences predicted to be disordered with specified fractions of various amino acids. With this function, you can specify multiple amino acids simultaneously, and each fraction should be specified using a decimal value (for example, if you want one-tenth of the amino acids to be alanine use `A=0.1`).

For each amino acid, the default maximum values are as follows - 

	"A" - 0 : 0.9, 
	"R" - 0 : 1.0, 
	"N" - 0 : 1.0, 
	"D" - 0 : 1.0, 
	"C" - 0 : 0.16, 
	"Q" - 0 : 0.72, 
	"E" - 0 : 1.0, 
	"G" - 0 : 1.0, 
	"H" - 0 : 1.0, 
	"I" - 0 : 0.2, 
	"L" - 0 : 0.26, 
	"K" - 0 : 1.0, 
	"M" - 0 : 0.26, 
	"F" - 0 : 0.18, 
	"P" - 0 : 0.94, 
	"S" - 0 : 0.88, 
	"T" - 0 : 0.76, 
	"W" - 0 : 0.22, 
	"Y" - 0 : 0.22, 
	"V" - 0 : 0.3

Note that if you pass in requested fractions those fractions must add up to equal or less than 1.

In addition to specifying the specific amino acid fractions, other parameters can be passed to the `create.seq_fractions()` function:

1. `cutoff`:  The disorder cutoff used defines a threshold GOOSE uses to selected/reject sequences. A higher cutoff means higher confidence that the sequence is disordered. The default value is 0.6. If you have difficulty making your sequence, you might want to try lowering the cutoff value.

2. `attempts`: The number of attempts defines how many times GOOSE will try to generate a desired sequence. This is relevant because certain parameter combinations of values are more challenging than others, and GOOSE implements a stochastic design algorithm such that different sequences are generated every time. For harder sequence compositions, you may need to increase this from the default value of 100. 

3. `max_aa_fractions`: If you wish to generate sequences with extreme compositions it may be necessary to over-ride the default max fractional values. This can be achieved by passing a max_aa_fractions dictionary, which should specify key-value pairs for amino acid-max fraction information. 


#### Examples

**Just specifying a single amino acid fraction:**

    create.seq_fractions(100, Q=0.3)
    'QEQNGVDQQETTPRQDYPGNQQPNQQAEGQQMQSTKMHDQHDSVNEDQEQNQNPWGHQPHMKGESNSSAREAQSEDQQNQAQNQQQNHDSTQQQDGQMDQ'

**Note**: Some fractions of amino acids are simply not possible. For example, GOOSE cannot make a sequence with W (tryptophan) greater than 0.2!

**Specifying multiple amino acids:**

    create.seq_fractions(100, Q=0.3, S=0.3, E=0.1)
    'QEQQSQKASQSQVESQDSSESSAPGSSQMHQQQSQSQEGMEQHQSSVGNSSSYPQSEQSEQQRQQSSQDQQQQSSSQTSEENSQSRQHDMSDTEMSGSQR'

**Note** - 
Some combinations of amino acids are simply not possible to make that are predicted to be disordered using the default settings. For example, while you can have up to 0.2 for W, if you have 0.18 for W and 0.16 for Y (both below their maximums), the total number of aromatic residues makes it unlikely that the sequence will be predicted to be disordered.


**Specifying none of a specific amino acids:**
If you want to exclude an amino acid, you can set it equal to 0.

    create.seq_fractions(50, A=0)
    'NKERPTGSWDEPPFDEGSSGMTNEDMGNKPYPTTDMQPEKWPQNDQQGST'
    
**Overriding default max fractions:**  

	create.seq_fractions(100, Y=0.5, max_aa_fractions={'Y':1}) 
	'SSYYYYYSYSSYYSYSSGHYYSYSSYYYSSSYYSSYGGTYGYYSYSYGYYSSYYYSYSSNYYYYYYYYSSYGNSGYGGYYSYYSSSQHHYSSYYYSYYSY'
 

 

## Creating Sequence Variants in Python

Apart from simply generating sequences, GOOSE can help you make different types of sequence variants. In contrast to when you generate a sequence, the primary input into the sequence variant functions are your sequence of interest. 

### An important note on disorder cutoffs when creating sequence variants

One problem we encountered when finding ways for people to easily make sequence variants occurs when something with a low predicted disorder score is used as the input sequence. In this situation, if GOOSE has a hard line cutoff disorder value that it must get to in order to return the sequence variant to you, it will almost certainly be unable to do so. To bypass this issue, GOOSE will first examine the disorder of your input sequence that is being used for sequence variant generation. Then, GOOSE will use the disorder values across your input sequence as the minimum threshold values for disorder predictions. All returned variants will have at a minimum the same amount of predicted disorder per residue as the input sequence *as predicted by metapredict V2*.


#### Types of sequence variants

``new_seq_constant_class_var()`` - A function to generate a variant where the sequence composition is new but the numbers of each residue from each class is the same. The overall properties of the generated sequence will also be constant. The order of the amino acids by class from the input sequence is not a constraint when making this variant.

``new_var()`` - Function to generate a variant sequence that is completely different in sequence to the input but has all the same overall properties. Does not account for specific classes of residues.

``constant_residue_var()`` - function that will generate a new sequence variant where specific residues are held constant. The variant will have the same aggregate properties as the original sequence.

``shuffle_var()`` - Variant that will shuffle specific regions of an IDR. Multiple regions can be specified simultaneously.


``kappa_var()`` - Variant where you can alter the charge asymmetry by changing the kappa value. Requires the presence of positively charged and negatively charged residues in the original sequence. Higher kappa values increase charge asymmetry, lower kappa values reduce charge asymmetry. Values can be between 0 and 1. 

``minimal_var()`` - Function for generating a variant that will change any properties including hydropathy, fcr, ncpr, and scd (sequence charge decoration, which is another measurement of sequence charge asymmetry) to those that you want to change while minimizing the number of residues changed in the returned variant sequence from the original sequence. The more you change a given property, the more the returned variant sequence will differ from the original.

``constant_class_var()`` - function to generate a variant with the same properties as the input variant as well as the same order of amino acids as far as class and the same number in each class. It will try to change the sequence as much as possible within these constraints.

``hydro_class_var()`` - Function to make a sequence variant that adjusts the hydropathy while keeping the position and number of amino acids the same by class of amino acid, similar to the ``constant_class_var()``. Hydropathy is simply adjusted by changing what the residue at that position is by swapping that residue with others that are in the same class but have differing hydropathy values.

**A note about FCR, NCPR, and all props class vars**
For the ``fcr_class_var()``, ``ncpr_class_var()``, and ``all_props_class_var()`` variants, the changes to amino acid classes is **MINIMIZED** but not entirely avoidable. This is because if you (for example) change FCR in your sequence, it is IMPOSSIBLE to keep the order and number of all amino acids by class the same in the returned variant. Similarly, with the NCPR variant, if you change the NCPR to the extent that the FCR has to change as well, then it will change the order / number of amino acids by class. Finally, for FCR and NCPR values for these variants, GOOSE will get AS CLOSE AS POSSIBLE. However, sometimes FCR/NCPR value pairs are not mathematically possible, so GOOSE has to try to get as close as is possible.

``fcr_class_var()`` - Function to make a sequence variant that adjusts the FCR while minimizing changes to the position and number of amino acids by class.

``ncpr_class_var()`` - Function to make a sequence variant that adjusts the NCPR while minimizing changes to the position and number of amino acids by class.

``all_props_class_var()`` - Function to make a sequence variant that adjusts the FCR, NCPR, hydropathy, and kappa values while minimizing changes to the position and number of amino acids by class. If you don't specify one of the values, GOOSE will keep it the same as it was in the input sequence.

``asymmetry_var()`` - Function to make a sequence where a class of residues (see below for classes) or a user-specified list of residues is changed to become more or less asymmetrically distributed throughout the sequence. Does NOT change sequence composition. The returned sequence will be as disordered as the input sequence at minimum, but you might not be able to increase asymmetry past a certain threshold due to it reducing predicted disorder.


For all class variants, the classes are categorized as followed:

aromatic : 'F', 'W', 'Y' 
polar : 'Q', 'N', 'S', 'T' 
positive : 'K', 'R' 
negative : 'D', 'E' 
hydrophobic' : 'I', 'V', 'L', 'A', 'M'
Special Cases : 'C', 'P', 'G', and 'H'
The 'Special Cases' residues are, for any function that accounts for the class of a residue, not interchangable with any other residues. 

**For ALL** sequence variants, you can specify ``cutoff``, which changes the disorder cutoff value. A higher cutoff means higher confidence that the sequence is disordered. The default value is 0.6.

### The constant_class_var()

The ``constant_class_var()`` generates a variant that keeps the order of amino acids the same by class but changes them as much as possible **while keeping the overall properties of the returned variant the same as the original sequence**. 

**Example**

    test = 'QEQNGVDQQETTPRQDYPGNQQPNQQAEGQQMQ'
    create.constant_class_var(test)
    NDNNGAENNDQQPRNEYPGNNNPTNNADGSNAS


### The new_seq_constant_class_var()

The ``new_seq_constant_class_var()`` keeps the same number of each class of residues but will return a sequence with a new overall sequence composition The overall properties of the generated sequence will also be constant.

**Example**

    test = 'QEQNGVDQQETTPRQDYPGNQQPNQQAEGQQMQ'
    create.new_seq_constant_class_var(test)
    NENAPEDQENNNRNPNGNQNQANQNGPFDSAGT


### The new_var()

The ``new_var()`` generates a variant that is completely different in sequence to the input. It does not account for classes of residues. The returned sequence will simply have the same overall properties as the input sequence.

**Example**

    test = 'QEQNGVDQQETTPRQDYPGNQQPNQQAEGQQMQ'
    create.new_var(test)
    MEHPTHDQYDQNHKQEPTGSNPNGTPHETNPQP


### The constant_residue_var()

The ``constant_residue_var()`` generates a sequence variant where specific residues are held constant. The variant will have different residues than the input sequence (with the exception of those specified to be held constant), **but the overall properties will remain the same between the variant and the original sequence**. You can specify more than one residue to be held constant at once.

**Example with one residue constant**

    test = 'QEQNGVDQQETTPRQDYPGNQQPNQQAEGQQMQ'
    create.constant_residue_var(test, constant=['T'])
    GEPNSQEQHDTTNRGDSQHPIQNNQNPDMPSHN

**Example with two residues constant**

    test = 'QEQNGVDQQETTPRQDYPGNQQPNQQAEGQQMQ'
    create.constant_residue_var(test, constant=['T', 'Q'])
    QEQSANDQQETTPKQEAPSPQQASQQHEGQQPQ


### The shuffle_var()

The ``shuffle_var()`` generates a variant sequence that will shuffle specific regions of an IDR. Multiple regions can be specified simultaneously. Regions being shuffled cannot overlap with each otehr
**Note** - The shuffle_var does **NOT** use index values like you would normally in Python. For the shuffle_var, 1 = the first amino acid in the sequence **NOT 0**. 

**Example with one shuffled region**

    test = 'QQQEEENNNDDDQQQEEENNNDDD'
    create.shuffle_var(test, shuffle=[3,9])
    QQNQENNEEDDDQQQEEENNNDDD

**Example with two residues constant**

    test = 'QQQEEENNNDDDQQQEEENNNDDD'
    create.shuffle_var(test, shuffle=[[3,9], [15, 23]])
    QQNNEEQNEDDDQQNDENNEDEQD

**Notice that when you specify 2 regions, you use a list of lists (a nested list).**

**Note**- 
**The following variants can change the overall properties of the generated sequence, unlike previous variants.**


### The hydro_class_var()

The ``hydro_class_var()`` makes a variant sequence that adjusts the hydropathy only by switching between amino acids with different hydropathy values within the same class. Therefore, the order of amino acids *by class* will be the same in the returned variant, but the hydropathy will be adjusted to your desired value. There is only a limited extent to which the hydropathy can be altered due to the fact that amino acid classes cannot be changed. If you try to change to a value outside of the possible hydropathy values, the error message will include the minimum and maximum possible theoretical values.


**Example decreasing hydropathy** - 
The starting hydropathy of the sequence below is  2.0272. Let's raise it to around 2.7.

    test = 'GNGGNRAENRTERKGEQTHKSNHNDGARHTDRRRSHDKNAASRE'
    create.hydro_class_var(test, hydropathy=2.7)
    GTGGTKIETKTEKKGETTHKTTHTDGLKHTDKKKTHDKSAASRE

**Example where hydropathy is raised higher than possible**

    test = 'GNGGNRAENRTERKGEQTHKSNHNDGARHTDRRRSHDKNAASRE'
    create.hydro_class_var(test, hydropathy=3.7)
    goose.goose_exceptions.GooseInputError:
    Unable to get to objective hydropathy without changing classes of residues.
	For this sequence the lowest possible hydrpathy is 1.611364.
	For this sequence the highest possible hydropathy is 2.834091.


### The fcr_class_var()

The ``fcr_class_var()`` makes a variant sequence that adjusts the FCR while minimizing changes to the order/number of amino acids *by class*. There is only a limited extent to which the fcr can be altered due to the fact that some FCR/hydropathy values are not compatible.


**Example decreasing FCR** - 
The starting FCR of the sequence is 0.409. Let's lower it to 0.23.

    test = 'GNGGNRAENRTERKGEQTHKSNHNDGARHTDRRRSHDKNAASRE'
    create.fcr_class_var(test, fcr=0.23)
    GNGGNRAQNNTNRNGEQTHQSNHNRGADHTQRDRSHRQNAASRN


**Example increasing FCR** - 
The starting FCR of the sequence is 0.409. Let's increase it to 0.5.

    test = 'GNGGNRAENRTERKGEQTHKSNHNDGARHTDRRRSHDKNAASRE'
    create.fcr_class_var(test, fcr=0.23)
    GNGGREARNKTDKDGRQTHDSRHRDGARHTKEKESHRRDAASRE


### The ncpr_class_var()

The ``ncpr_class_var()`` makes a variant sequence that adjusts the ncpr while minimizing changes to the order/number of amino acids *by class*. There is only a limited extent to which the ncpr can be altered due to the fact that if you change the ncpr outside of the range that is possible for the FCR value, GOOSE will automatically alter the FCR value to make the generation of the variant possible. However, some FCR/hydropathy value combinations are not possible to make.

**Example decreasing NCPR** - 
The starting NCPR of the sequence is 0.909. Let's lower it to 0.0.

    test = 'GNGGNRAENRTERKGEQTHKSNHNDGARHTDRRRSHDKNAASRE'
    create.ncpr_class_var(test, ncpr=0)
    GNEGRGENRAENRTDGKQDTKHDSRNDHRNDGKAEHRTSHNAAS


**Example increasing NCPR** - 
The starting NCPR of the sequence is 0.909. Let's increase it to 0.4.

    test = 'GNGGNRAENRTERKGEQTHKSNHNDGARHTDRRRSHDKNAASRE'
    create.ncpr_class_var(test, ncpr=0.4)
    GTGGSRARNRTKRKGRQTHKSNHNKGARHTRRRRSHRKNAASRK


### The all_props_class_var()

The ``all_props_class_var()`` makes a variant sequence that adjusts the FCR, NCPR, kappa, and mean hydropathy while minimizing changes to the order/number of amino acids *by class*. There is only a limited extent to which the NCPR or NCPR can be altered due to the fact that some FCR/hydropathy values are not compatible.

**Example changing all properties** - 
In this example we will change all 4 possible properties.

    test = 'GNGGNRAENRTERKGEQTHKSNHNDGARHTDRRRSHDKNAASRE'
    create.all_props_class_var(test, hydropathy=2.5, fcr=0.23, ncpr=0, kappa=0.1)
    GTDGGETIETTESNDGQTHSNHNQGAHTNKSHQKQNAARSKNKQ


**Example changing 2 properties** - 
In this example we will just change kappa and hydropathy.

    test = 'GNGGNRAENRTERKGEQTHKSNHNDGARHTDRRRSHDKNAASRE'
    create.all_props_class_var(test, kappa=0.3, hydropathy=2.6)
    KGKRTKGGTKKKIKKTKRTGTTHTTHTGAHTSDHDENAADSEEE


### The kappa_var()

The ``kappa_var()`` variant allows you to change the charge asymmetry of a sequence **provided it has postively and negatively charged residues.** Higher kappa values increase charge asymmetry, lower kappa values reduce charge asymmetry. Values can be between 0 and 1. 

**Example** - 

First we can take something with very symmetrically positions oppositely charged amino acids and increase the kappa value. For reference, the starting kappa value for this 'test' sequence was 0.0012.

    test = 'QNEKRDQNEKRDQNEKRDQNEKRDQNEKRDQN'
    create.kappa_var(test, kappa=0.9)
    KRRRRKKKRKQNQNQNQNQNEEDQDDEDDEEN

Now we can take this newly generated and make the charges more moderately symmetrical (something between what we started with and what we made in the previous example).

    previous_variant = 'KRRRRKKKRKQNQNQNQNQNEEDQDDEDDEEN'
    create.kappa_var(previous_variant, kappa=0.35)
    QEEEEDDDRDREKDKKRKNQNQNQNQNQRRKN

**note** GOOSE will allow deviation from your input kappa value by up to 0.02. This is to keep GOOSE from being extremely slow. If you need something closer to your desired value, you can try generating a few variants. You'll likely quickly get the exact value you want within a few tries.


### The minimal_var()

The ``minimal_var()`` variant allows you to input a sequence of interest and then choose properties including hydropathy, fcr, ncpr, and scd (sequence charge decoration, which is another measurement of sequence charge asymmetry(SCD)) to alter in your returned sequence. SCD will eventually be changed over to kappa for charge asymmetry. The objective of this variant is to generate a sequence with the desired input properties while changing as few amino acids in the sequence as possible. The more you change a given property, the more the returned variant sequence will differ from the original.

**Example** - 

**Changing one property** - 

    test = 'GNGGNRAENRTERKGEQTHKSNHNDGARHTDRRRSHDKNAASRE'
    create.minimal_var(test, hydropathy=3)
    AGAGGRAEGRGERKGEGGGKGGAGDGARGGDRRRGGDKGAAGRE

**Changing multiple properties** - 

    test = 'GNGGNRAENRTERKGEQTHKSNHNDGARHTDRRRSHDKNAASRE'
    create.minimal_var(test, hydropathy=3, fcr=0.2)
    GSGGSRAENRTEQQGEQTSSSSSSGGARSTTRRSSSSKSAASRG



### The asymmetry_var()

The ``asymmetry_var()`` allows you to change the distribution of either a class of amino acids or a user-specified list of amino acids. You can increase or decrease residue distribution in your sequence of interest. By default will only slightly change the asymmetry of the sequence, but you can specify the ``changes`` property to increase or decrease the amount that the function changes the asymmetry.

**Example** - 

**Changing aliphatics, no specification of changes property** - 

    test = 'GNGGNIVRAENRTERKGEQLATHKSNHNDGARHTDRRLMRSHDKNAASRE'
    create.asymmetry_var(test, 'decrease', 'aliphatic')
    GNGGNIVRAAENRTERKGEQLATHKSNHNDGARHTDRRLMRSHDKNASRE
    
**Example** - 

**Changing aliphatics, increased number of changes** - 

    test = 'GNGGNIVRAENRTERKGEQLATHKSNHNDGARHTDRRLMRSHDKNAASRE'
    create.asymmetry_var(test, 'increase', 'aliphatic', changes=20)
    RNNGGLAIVLAAAAMGENRTERKGEQTHKSGHNDDRHTDRRRSHNKNSRE
    

**Changing aliphatics, decrease asymmetry** - 

    test = 'RNNGGLAIVLAAAAMGENRTERKGEQTHKSGHNDDRHTDRRRSHNKNSRE'
    create.asymmetry_var(test, 'decrease', 'aliphatic', changes=20)
    RNNGGLAGEANRTERMKGEQATHKSGAHNDDRHVITDLRRRSHNAKNSRE
    

**Changing custom list, increase asymmetry** - 

    test = 'RNNGGLAIVLGAAAMGGGGNRTERKGEQTHKSGGNDDRHTDRGGSHNKNGRE'
    create.asymmetry_var(test, 'increase', ['G'], changes=20)
    RNNLAIVLAAAMGGGGGGGGGGGGGNRTERKEQTHKSNDDRHTDRSHNKNRE
    


## Generating sequences with predicted secondary structure

Alright. We know - this is an IDR sequence generation and sequence variant generation tool. However, sometimes we just can't resist trying something that... *might* work. TL;DR, GOOSE can make alpha helices, beta strands, and beta sheets. We don't have functionailty to let you easily make complex structures yet **but we can confirm that with a little playing around you can definitely make some pretty cool stuff**. While 'doing pretty cool stuff' isn't a great reason to do something, the reality is that IDRs interact with folded domains. Sure, this might not be the best approach to study this. However, you can control the length of these secondary structures, so that might be reason enough to try it out. And even though we haven't quite figured out what to do with it, we wanted to make it an avaialble feature (since it worked anyways) to see what anyone else might do with it. 

***NOTE*** - While we did test these functions extensively and did our best to make sure that they generate the secondary structures as described for each function, **it is very important to double check this after sequence generation**. We cannot gaurentee that sequences generated from these functions will *actually* form the secondary structure - they are only *predicted to form the structure*. We only verified these functions using predicted structures from AlphaFold2.


All of the functionality for generating sequences with predicted secondary structures are also used by import **create** from **goose**. 


### Generating an alpha helix in GOOSE

The ``alpha_helix()`` function will produce a sequence that is predicted based off of DSSP scores to form a helix. This has consistently worked in so far as sequences generated using this functioin tend to be predicted to form a helix by AlphaFold2. The only paramter for this function is to specify the length. Lengths can be between 8 and 150.

**Example** - 

    create.alpha_helix(50)
    WFLLWWAQELQQTQAWLMLYCRMMYEQLFVWLVAQRWWWQWWYQLIKKLS


### Generating a beta strand in GOOSE

The ``beta_strand()`` function will produce a sequence that is predicted based off of DSSP scores to form a beta strand. The only paramter for this functions is to specify the length. Lengths can be between 5 and 34.

**Example** - 

    create.beta_strand(20)
    'VVVVVEKVEVVEVVEVKVVV'

### Generating a beta sheet in GOOSE

The ``beta_sheet()`` function will produce a sequence that is predicted based off of DSSP scores to form short beta strands separated by sequences predicted to form coils. Beta strands need the coils between them so that they can fold into a beta sheet. The only paramter for this functions is to specify the length. Lengths can be between 18 and 400. **Note** Not every sequence generated by this function is predicted to form a beta sheet by AF2, but most are. It's good to run it through AF2 to check before using it. 

**Example** - 

    create.beta_sheet(100)
    ''PFPEVYVVEFKVVVVVVPNSTPANGSRPTKPVVVVEYEVEVVEVVFKQQPPVYIVVEIEVEVVEVVHSHPPEVYIVEVKVYVIVVGPPLPPGPGVPPSPP''


## About sequence analysis in GOOSE

GOOSE provides powerful sequence analysis tools including eight machine learning-based predictors that utilize a LSTM BRNN architecture (nine if you included metapredict v2). All of this functionality is in the 'analyze' module. To use this module simply start by importing it

    from goose import analyze

and then you have a full suite of sequence anlysis tools. The analyze module includes tools for calculating and predicting the following characterstics of your protein of interest (which doesn't even need to be an IDR made in GOOSE!). 

1. Sequence length
2. Fraction of charged residues (FCR)
3. Net charge per residue (NCPR)
4. Average hydropathy
5. Sigma is a property that quantifies charge asymmetry and is defined as the NCPR^2 / FCR
6. delta is a summation of sigma across a sequence using a blob length of 5.5. Basically, more stuff to do with charge asymmetry.
7. kappa - A measurement of charge asymmetry where the max value (1) is the greatest possible charge asymmetry for a given sequence and the min value (0) is the most symmetrical positions possible for oppositely charged residues.
8. Predicted phosphosites for S, T, and Y phosphorylation sites
9. Predicted cellular localization signals including those for nuclear localization, nuclear export and mitochondrial targeting. We will add more as data becomes available.
10. Predicted transcriptional activation domains
11. The fractions of all amino acids in the sequence.


## Using the analyze module in GOOSE

There are 5 functions available in the analyze module after you import it from GOOSE.

### Analyzing general properties

To analyze general properties in GOOSE, you can use the 'properties' function.
This function returns a dict containing all basic properties calculated including length, FCR, NCPR, hydropathy, kappa, and fractions of amino acids.

**Example**

	test = 'GNGGNRAENRTERKGEQTHKSNHNDGARHTDRRRSHDKNAASRE'
	analyze.properties(test)
	{'length': 44, 'FCR': 0.409091, 'NCPR': 0.090909, 'hydropathy': 2.027273, 'kappa': 0.015391434577958246, 'fractions': {'A': 0.09091, 'C': 0.0, 'D': 0.06818, 'E': 0.09091, 'F': 0.0, 'G': 0.11364, 'H': 0.09091, 'I': 0.0, 'K': 0.06818, 'L': 0.0, 'M': 0.0, 'N': 0.13636, 'P': 0.0, 'Q': 0.02273, 'R': 0.18182, 'S': 0.06818, 'T': 0.06818, 'V': 0.0, 'W': 0.0, 'Y': 0.0}}


### Predicting phosphosites

GOOSE has 3 separate networks each trained on a different phosphorylation sites (S, T, and Y phosphosites). The phosphosites() function in analyze gives you information on all of them at once. 

**Example**

	test = 'GNGGNRAENRTSSKSERKGEQTHKSNHNDGARHTDRRRSHYDKNAASRE'
	analyze.phosphosites(test)
	{'S': [11, 12], 'Y': [40], 'T': [21, 33]}

In the returned dict, the S is for serine phosphosites, Y for tyrosine phosphosites, and so on. If GOOSE does not predict a phosphosite for a location, it will not return anything for that amino acid. **It is extremely important to note that this predictor is not a gaurentee of a phosphorylation event!**. Protein phospohrylation is incredibly complex, this predictor should be used more as a way to check on something that you want to avoid being phosphorylated (although as with any 'predictor', nothing can be gaurenteed 100%).


### Predicting subcellular localization

If you design an IDR and it ends up somewhere you don't want it to, that's a bad day in the lab. To try to mitigate this problem, we are working on machine learning-based predictors of cellular localization sequences to try to determine where a given protein might end up. As stated in the phosphosite section, this is not a perfect solution, but it is nonetheless better than nothing. This function uses three separate LSTM BRNN networks: 1. NLS, 2. NES, 3. mitochondrial targeting sequences. 

**Example**

For a known mitochondrial protein...

	test = 'MAAAAASLRGVVLGPRGAGLPGARARGLLCSARPGQLPLRTPQAVALSSKSGLSRGRKVMLSALGMLAAGGAGLAMALHS'
	analyze.cellular_localization(test)
	{'mitochondria': {'MAAAAASLRGVVLGPRGAGLPGARARGLLCSARPGQLPLRTPQAVALSSKSGLSRGRKVMLSAL': [1, 65]}, 'NES': 'No NES sequences predicted.', 'NLS': 'No NLS targeting sequences predicted.'}

In the returned dict, the key 'mitochondria' brings up the sequence predicted to be the targeting sequence as well as the coordinates of that sequence (where 1 is the first amino acid). For the other two keys, 'NES' for nuclear export sequences and 'NLS' for nuclear localization sequences, because none were detected the value for each of those key value pairs just states that none were predicted.


### Predicting transcriptional activation domains

If you design an IDR that could bind to DNA, you might not to want it to inadvertantly have a transcriptional activation domain (TAD). You can check that using GOOSE. 

**Example**

For a subset of a protein with a known TAD...

	test = 'PNNLNEKLRNQLNSDTNSYSNSISNSNSNSTGNLNSSYFNSLNIDSMLDDYVSSDLLLNDDDDDTNLSR'
	analyze.transcriptional_activation(test)
	{'TGNLNSSYFNSLNIDSML': [31, 49]}
	
If there is a TAD present, the function returns the TAD subsequence along with the coordinates for the TAD in the input sequence. Importantly, once again, this is just a predictor and does not gaurentee that a TAD is present or absent from your sequence.


### Predict everything

If you just want a summary of... well basically everything we've covered so far from properties to all predicted features, that's pretty easy to do! 

**Example**

	test = 'PNNLNEKLRNQLNSDTNSYSNSISNSNSNSTGNLNSSYFNSLNIDSMLDDYVSSDLLLNDDDDDTNLSR'
	analyze.everything(test)
	{'length': 69, 'FCR': 0.202899, 'NCPR': -0.115942, 'hydropathy': 3.413043, 'sigma': 0.066252, 'delta': 0.057173, 'SCD': 0.78989, 'kappa': 0.24406233325921825, 'predicted phosphosites': {'S': [67], 'Y': [18, 37, 50], 'T': [30, 64]}, 'predicted cellular localization': {'mitochondria': 'No mitochondrial targeting sequences predicted.', 'NES': 'No NES sequences predicted.', 'NLS': 'No NLS targeting sequences predicted.'}, 'predicted transcriptional activation': {'TGNLNSSYFNSLNIDSML': [31, 49]}, 'fractions': {'A': 0.0, 'C': 0.0, 'D': 0.14493, 'E': 0.01449, 'F': 0.01449, 'G': 0.01449, 'H': 0.0, 'I': 0.02899, 'K': 0.01449, 'L': 0.14493, 'M': 0.01449, 'N': 0.23188, 'P': 0.01449, 'Q': 0.01449, 'R': 0.02899, 'S': 0.21739, 'T': 0.04348, 'V': 0.01449, 'W': 0.0, 'Y': 0.04348}, 'sequence': 'PNNLNEKLRNQLNSDTNSYSNSISNSNSNSTGNLNSSYFNSLNIDSMLDDYVSSDLLLNDDDDDTNLSR'}

The analyze.everything() function will return a dictionary holding all of the information from sequence properties to predicted phosphosites, cellular localization, and transcriptional activation domains all from one simple function!

### Predict differences between sequences

If you generate a sequence variant and want to see if you've broken or introduced any sequence features including TADs, cellular localization signalgs, and phosphosites, you can use the ``analyze.prediction_diffs()`` function. The function takes in two sequences as the input and then returns the predicted differences between those sequences. 

**Example**

    test1 = 'PNNLNEKLRNQLNSDTNSYSNSISNSNSNSTGNLNSSYFNSLNIDSMLDDYVSSDLLLNDDDDDTNLSR'
    test2 = 'PTTITEKIKTTITTDTTTFTTTITTTTTTSTGNLNSSYFNSLNIDSMLDDYVSSDLLLNDDDDDTNLSR'
    analyze.prediction_diffs(test1, test2)
    {'S phosphorylation': 'No differences.', 'T phosphorylation': 'sequence 1: [31, 65], sequence 2: [65]', 'Y phosphorylation': 'sequence 1: [19, 38, 51], sequence 2: [38, 51]', 'NLS': 'No differences.', 'NES': 'No differences.', 'mitochondrial': 'No differences.', 'predicted transcriptional activation': ['Sequence 1 predicted TAD - TGNLNSSYFNSLNIDSML : [31, 49] not in sequence 2', 'Sequence 2 predicted TAD - GNLNSSYF : [32, 40] not in sequence 1']}


## Generating sequence libraries in GOOSE

### Generating sequnce libraries by properties

To generate sequence libraries by specifying properties, use the ``create.seq_property_library()`` function. An important things to note ***GOOSE automatically gets rid of sequences not possible to make***. For example, a sequence with an NCPR value where the absolute value of the NCPR value is greater than the FCR will not be included because it's not possible to generate. In addition, GOOSE will check the hydropathy value and see if it is possible based on the FCR. If it's not possible, GOOSE will not make it. However **for incompatible hydropathy / charge values**, GOOSE will print out the sequences it was not able to generate and print them unless you set ``silent_failed_seqs`` to True. In this function, you can specify the length, FCR, NCPR, hydropathy, kappa, and disorder cutoff values. **Note** GOOSE will do it's best to get the kappa value spot on, but it does allow for some error. It will also also adjust the FCR to match the NCPR if the two values are not compatible. This function will return a dictionary of sequences where each sequence is named after the property specified for generating the sequence.

 
For this function, you can specify the property as a single value, a list of two values, or a list with three values where GOOSE will make all possible values from the first number of the list to the second number of the list at an interval equal to the third value of the list.

**Example**

    create.seq_property_library(40, FCR=0.1, NCPR=[0, 0.1], hydropathy=[2, 4, 0.5])

    {'>FCR_0.1_NCPR_0_hydropathy_2.0': 'QKPSQNKNHTPTGQGNSHPQDHPEQQQQQPPQQQSTQNTP', '>FCR_0.1_NCPR_0_hydropathy_2.5': 'NSNSTSENNKQNNGPHSPGTSQPPNFQPSAPQENSGNGKH', '>FCR_0.1_NCPR_0_hydropathy_3.0': 'SAPTQDPQSHYTQGGNEQTGGSPTGPPGWSHAKRSPSGQG', '>FCR_0.1_NCPR_0_hydropathy_3.5': 'NRSSGSCAPLNSAGGTTPGNKEVADPPPPGSTGSWGHQTH', '>FCR_0.1_NCPR_0_hydropathy_4': 'PSTHSSAGPSDTSASSSARSVPSSDSAVKSSCGSGASTTS', '>FCR_0.1_NCPR_0.1_hydropathy_2.0': 'QPPSPHQPLSHHSQQHNGNTKKQKSHQPNKNNSHPNNHNQ', '>FCR_0.1_NCPR_0.1_hydropathy_2.5': 'SGHSQGQNTHTKQGRQRGHGHVSPNQQHSSTPQHMQSPKT', '>FCR_0.1_NCPR_0.1_hydropathy_3.0': 'TSPSNHPQKPGPTPAGMQTGGTPGKTKHPHHPGSKLQQYT', '>FCR_0.1_NCPR_0.1_hydropathy_3.5': 'SAMLNASAGNPSGGQQRNSANLGPSRTTQKTSAQARSPTG', '>FCR_0.1_NCPR_0.1_hydropathy_4': 'PAPKPGAKVVSTSALQRVAKSSPPACSPGTHPGSSPTTSS'}

In the example above, the first value in the function is the length. This value must be a singlue integer value and is **required**. The second value, ``FCR`` is specified as a single value, so all sequences generated will have that value. The third value ``NCPR`` is specified as a list, so GOOSE made a set of sequences where NCPR was equal to the first value in the list and then a set where NCPR was equal to the second value in the list. Finally, ``hydropathy`` was set equal to a list with 3 values. This means GOOSE was told to generate sequences with a range of the first value of the list ``2``, to the second value in the list, ``4``, at an interval equal to the third value of the list ``0.5``. This resulted in the creation of sequences with values 2.0, 2.5, 3.0, 3.5, and 4.0.
**If the third value, which is the interval value, is cannot be equally used between the range of sequences, GOOSE will just use the maximum value as the last value.** For example, hydropathy = [2, 4, 1.1] would result in hydropathy values of 2, 3.1, and 4. In this example ``kappa`` was not specified, so GOOSE had no constraints on kappa values.
In addition, you can add a random name to the end of each sequence name by setting ``random_name=True``, which allows you to avoid problems that Jeff has.

**Example**

    create.seq_property_library(40, FCR=0.1, NCPR=[0, 0.1], hydropathy=[2, 4, 0.5], random_name=True)

    {'>FCR_0.1_NCPR_0_hydropathy_2.0_F0K7D2N5N6': 'TPNHTQPHKNHDNNNPSHNHTGNNPTNPQEHKGSQTNQPT', '>FCR_0.1_NCPR_0_hydropathy_2.5_G5R2A2L8F8': 'THQNPEDTHTTHPSMSRSNNPQLQNNGQRPAPPSSPHGHN', '>FCR_0.1_NCPR_0_hydropathy_3.0_E8V4W5C2N2': 'GPGSEHPHAPGDSSTGNNTSGPTKPSTGGALSQNRQPQYP', '>FCR_0.1_NCPR_0_hydropathy_3.5_C2C3D1F5P4': 'PPTQQPNGQSMSGGARHTTAAAAEGSARMAELSQNHSNGG', '>FCR_0.1_NCPR_0_hydropathy_4_I3S8I0G9W4': 'APTKGVAPETRSTSPAASSGAGGGGSSPASSMSPSSGDGS', '>FCR_0.1_NCPR_0.1_hydropathy_2.0_N8E1Y2R5D0': 'PPPSTGHQKQNYSQNHHNNPPQHQRWHRNGPPRPNSHQSG', '>FCR_0.1_NCPR_0.1_hydropathy_2.5_H3H7I2S0W7': 'NSGGSKRSSSPGPTPNQPQNGRNMPMPQNRQNHTNFQNTP', '>FCR_0.1_NCPR_0.1_hydropathy_3.0_I2K0M6E2T0': 'TRSHQQPQMHGMPSTSPNGCQTLNSPSSMRKGPPPQSGKN', '>FCR_0.1_NCPR_0.1_hydropathy_3.5_H3Q4E1L7W8': 'QTSSPQTMGRSQTTTGSASMQSSGMASTSRPPRFSSRSTG', '>FCR_0.1_NCPR_0.1_hydropathy_4_A4D7R8W6V7': 'RTSPTSVKPPTSACKTAAGSTPMTRSPSSSTLAVNGPPAP'}

### Generating sequnce libraries by fractions

To generate sequence libraries by specifying fractions, use the ``create.seq_fractions_library()`` function. An important things to note ***GOOSE automatically gets rid of sequences not possible to make***. This includes where the fraction of amino acids is greater than 1 (for obvious reasons) and if the fraction of any amino acid specified is greater than the max_aa_fractions limit. The max_aa_fractions limit can be manually overridden (see below). 

 
For this function, you can specify the amino as a single value, a list of two values, or a list with three values where GOOSE will make all possible values from the first number of the list to the second number of the list at an interval equal to the third value of the list. If only two values are given, GOOSE just uses those two values and does not assume any interval.

**Example**

    create.seq_fractions_library(100, A=0.1, D=[0.1, 0.2], K=[0.1, 0.2, 0.05])

    {'>A_0.1_D_0.1_K_0.1': 'SKSSSGTKEHSEAEDNGEDGAATNHDHNDEHGRATGADDKKNHGHTKEHGAQHQSSQGNNNHDKSNSTRDAHNGARSDKRARNKEKQHQKGQAGENDHGE', '>A_0.1_D_0.1_K_0.15': 'EAAGGHQHGKRQSGKSQSADENKGRKKDESTNKDNTSRQSRETASQGKAKKNNGGPKKAGNQDDAQDESEGSQRSSQQAKDAKNGDDQTKTDEGHSTKAQ', '>A_0.1_D_0.1_K_0.2': 'TGGAGKDASAGDATKDRAKSDNKGKTKKERAAKTQNKSHNQAQEKRTGESSHKEKRKDGENQAKSHSKNHKQRKPADTQKTEDERHEEHGHEDKKDEDEQ', '>A_0.1_D_0.2_K_0.1': 'DSSNATTSNDQDDKSHDSNTQAHDQREVGNSKDSNSNASDDENKAGQENTSAEEDNPDDHEEKDDNDRDGHAKKKTSADKDGDNDREAKASHNGKNAEEG', '>A_0.1_D_0.2_K_0.15': 'DQGDEKAQTDASKSKNDTGAADKHGKAKQTGKEEENQDDGKTDDHSGPTDGQDNRGDKKSEGTDDKAKDQQDDTDEQATTTTKRAGHAADEDSTNRKKRS', '>A_0.1_D_0.2_K_0.2': 'SDDKDRRDKQAHSNKHADAKSNEASHRKKHAGKHGQDTGKKDDGQNKDSADKTHKTKDGDSEQKAHDTSEADQAKKDGDHNGEDGDEDGDKAGKKQGNKN'}

In the example above, the first value in the function is the length. This value must be a singlue integer value and is **required**. The second value, ``A`` is specified as a single value, so all sequences generated will have that value. The third value ``D`` is specified as a two item list, so GOOSE made a set of sequences where the fraction of ``D`` is either 0.1 or 0.2. Finally, ``K`` was set equal to a list with 3 values. This means GOOSE was told to generate sequences with a range of the first value of the list ``0.1``, to the second value in the list, ``0.2``, at an interval equal to the third value of the list ``0.05``. This resulted in the creation of sequences with values 0.1, 0.15, 0.2.
**If the third value, which is the interval value, cannot be equally used between the range of values from the lowest to the highest, GOOSE will just use start at the lowest value and increase until it can't any more and then will add the maximum value.** For example, K = [0.1, 0.2, 0.08] would result in K fraction values of , 0.1, 0.18, and 0.2.
In addition, you can add a random name to the end of each sequence name by setting ``random_name=True``. 

***Additional usage***

Some other things you can specify are:

``warn_user`` - used to determine whether to warn the user of any problems with generating the sequnces. By default is set to True, but you can set it to False. 
``robust_warnings`` - used to return a warning message FOR EVERY SEQUENCE THAT HAS A FRACTION VALUE NOT EQUAL TO THE INPUT VALUE. This can be annoying for large library generation and is by default set to False. Set to True to get more information on the sequences that have errors and what those errors are. 
``max_aa_fractions`` - used to override the max amino acid fractions. Input as a dict. Example below:

**Example**

    create.seq_fractions_library(100, A=0.1, D=[0.1, 0.2], K=[0.1, 0.2, 0.05], max_aa_fractions= {'K': 0.16})

    {'>A_0.1_D_0.1_K_0.1': 'TQHHDEKNRRAEANDSPNGDEHAQDGKHSAEKQRTQHAENSDRDHSEGAKGNNQHGRKKQENERRAGGGKQTHKNTSQDHGDRNAKDDAQNGQQHHNKHA', '>A_0.1_D_0.1_K_0.15': 'QRKGNSANSGERADHTGDHDTQNAATTGKRKDNKEKKNDKHSARAQNTDKKAHTEKGSKHATQNAHNESQPGGDETNSKKHASTGQGKGNNDSRKGRDDN', '>A_0.1_D_0.2_K_0.1': 'AQQRQDQGGDAKDADDRTDARKDTETSPAKQEQAGRSDDKGPDDTDQKAESPTESNERDQQGQETGDDKQQKKGSEDAHSQDQDGKGPDQGKDAHQAGSR', '>A_0.1_D_0.2_K_0.15': 'EGPQATSTDDEDDHHKSKDESADEGAKSGKRTEENDRAATDTAHHATKDHDDHHKTDGPEKTKDETKKADKEGHHKKDTAEKQEDNANSSTDDTQPSKDD'}

In the above example, we manually overrode the max fraction for K and set it to 0.16. This eliminated sequences where the K fraction was 0.2 like in the example above where the max_aa_Fractions were left as default.

## How to cite GOOSE

You can not currently cite GOOSE as we have yet to publish it (hopefully soon!). We would appreciate if you would mention GOOSE in your methods section with a link to the Github page so readers of your paper can understand how you generated the sequences you used.


### Copyright

Copyright (c) 2022, Ryan Emenecker - Holehouse Lab


#### Acknowledgements
 
Project based on the 
[Computational Molecular Science Python Cookiecutter](https://github.com/molssi/cookiecutter-cms) version 1.6.
